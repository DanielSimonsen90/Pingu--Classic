import { Base, CategoryChannel, Collection, Message, Snowflake, TextChannel } from 'discord.js';
import { Model, Document } from 'mongoose';

import BasePinguClient from '../pingu/client/BasePinguClient';
import Reason from '../helpers/Reason'
import Error from '../helpers/Error';

type SavedSchemas = 'PinguUser' | 'PinguGuild';
type ModelType<PT> = Model<Document<PT, any>, any, any>

interface IName { name?: string, tag?: string }
interface BaseT extends Base, IName { id: Snowflake }
interface BasePT extends IName { _id: Snowflake }
interface BaseManager<T> { 
    fetch(id: Snowflake, cache?: boolean, force?: boolean): Promise<T>,
    cache: Collection<Snowflake, T>
}

export class PinguCollection<T extends BaseT, PT extends BasePT> {
    constructor(
        client: BasePinguClient<any>, logChannelName: string, schemaName: SavedSchemas, 
        newPT: (item: T, client: BasePinguClient<any>) => PT, typeManager: (client: BasePinguClient<any>) => BaseManager<T>       
        ) {
        
        this._client = client;
        this._logChannelName = logChannelName;
        this._model = require(`../MongoSchemas/${schemaName}`) as ModelType<PT>;
        this._schemaName = schemaName;

        this._newPT = newPT;
        this._typeManager = typeManager
    }

    private _logChannelName: string;
    public get logChannel() {
        const guild = this._client.guilds.cache.get(this._client.savedServers.get('Pingu Support').id);
        const logChannelCategory = guild.channels.cache.find(c => c.type == 'category' && c.name.includes('Pingu Logs')) as CategoryChannel;
        return logChannelCategory.children.find(c => c.name.includes(this._logChannelName)) as TextChannel;
    }
    private _model: ModelType<PT>
    private _schemaName: SavedSchemas;
    private _inner: Collection<Snowflake, PT>

    private _newPT: (item: T, client: BasePinguClient<any>) => PT;
    private _typeManager: (client: BasePinguClient<any>) => BaseManager<T>
    
    private _client: BasePinguClient<any>;
    
    public async add(item: T, scriptName: string, reason: string): Promise<PT> {
        return this._client.DBExecute(async mongoose => {
            const pItem = this._newPT(item, this._client);
            const created = await new this._model(pItem).save();

            const _reason = new Reason('create', this._schemaName, pItem.name || pItem.tag, reason);
            this.log(scriptName, _reason, created ? null : new Error(`Unable to create ${this._schemaName}`));

            this._inner.set(item.id, pItem);
            return pItem;
        });
    }
    public get(item: T): PT {
        return this._inner.get(item.id);
    }
    public array(): PT[] {
        return this._inner.array();
    }
    public async update(pItem: PT, scriptName: string, reason: string): Promise<PT> {
        const item = await this._typeManager(this._client).fetch(pItem._id);
        if (!item) throw new Error(`${this._schemaName} not found!`);

        await this._model.updateOne({ _id: pItem._id as unknown }, pItem as any, null, async err => {
            const _reason = new Reason('update', this._schemaName, pItem.name || pItem.tag, reason);

            if (err) return this.log(scriptName, _reason, err);
            this.log(scriptName, _reason);

            this._inner.set(pItem._id, pItem);
        });
        return pItem;
    }
    public async delete(item: T, scriptName: string, reason: string): Promise<this> {
        await this._model.deleteOne({ _id: item.id as unknown }, null, err => {
            const _reason = new Reason('delete', this._schemaName, item.name || item.tag, reason);

            if (err) return this.log(scriptName, _reason, err);
            this.log(scriptName, _reason);

            this._inner.delete(item.id);
        });
        return this;
    }

    public find(predicate: (pItem: PT, item: T, index: number, self: this) => boolean): PT {
        const entries = this._inner.array();

        for (let i = 0; i < entries.length; i++) {
            const entry = entries[i];
            const item = this._typeManager(this._client).cache.get(entry._id);

            if (predicate(entry, item, i, this)) return entry;
        }
        return null;
    }
    public has(item: T): boolean {
        return this._inner.has(item.id);
    }

    public async refresh(client?: BasePinguClient<any>): Promise<this> {
        if (client) this._client = client;

        const dbEntries = (await this._model.find({}).exec()).map(collDoc => collDoc.toObject()) as PT[];

        this._inner = new Collection(dbEntries.map(entry => [entry._id, entry]));
        this._client.log('console', `Successfully refreshed entries for **${this._schemaName}**.`);
        
        return this;
    }
    public async log(script: string, reason: Reason, err?: Error): Promise<Message> {
        const logType = this._schemaName == 'PinguGuild' ? 'pGuild' : 'pUser';
        return this._client.log(logType, script, err ? reason.errMsg : reason.succMsg, err);
    }
}

export default PinguCollection;