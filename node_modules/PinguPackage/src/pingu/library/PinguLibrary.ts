import { Client, Guild, GuildChannel, Message, MessageEmbed, User } from 'discord.js';
import * as mongoose from 'mongoose';
import * as config from '../../config.json';

import { DefaultEmbedColor, Clients, DefaultPrefix, setActivity } from './client';
import { PermissionCheck, PermissionGranted, Permissions } from './permissions';
import { getServer, getSharedServers, SavedServers } from './servers';
import { Developers, isPinguDev } from './developers';
import { DanhoDM, getChannel, outages } from './channels';
import { eventLog, errorLog, consoleLog, latencyCheck, pGuildLog, pUserLog, raspberryLog, tellLog } from './logChannels';
import { EmbedField, Error } from '../../helpers';

class PinguLibrary {

    //#region Client
    public static setActivity(client: Client) { return setActivity(client); }
    public static DefaultEmbedColor = DefaultEmbedColor;
    public static DefaultPrefix(client: Client) { return DefaultPrefix(client); }
    public static Clients = Clients;
    //#endregion

    //#region Permissions
    public static PermissionCheck(check: { author: User, channel: GuildChannel, client: Client, content: string }, permissions: string[]) { return PermissionCheck(check, permissions); }
    public static readonly PermissionGranted = PermissionGranted;

    public static Permissions() { return Permissions; }
    //#endregion

    //#region Servers
    public static readonly SavedServers = SavedServers;
    private static getServer(client: Client, id: string) { return getServer(client, id); }
    public static async getSharedServers(client: Client, user: User) { return getSharedServers(client, user); }
    //#endregion

    //#region Pingu Developers
    public static Developers(client: Client) { return Developers(client); }
    public static isPinguDev(user: User) { return isPinguDev(user); }
    //#endregion

    //#region Channels
    public static getChannel(client: Client, guildID: string, channelname: string) { return getChannel(client, guildID, channelname); }
    public static async outages(client: Client, message: string) { return outages(client, message); }
    public static async DanhoDM(client: Client, message: string) { return DanhoDM(client, message); }
    //#endregion

    //#region Log Channels
    public static async errorLog(client: Client, message: string, messageContent?: string, err?: Error) {
        return errorLog(client, message, messageContent, err);
    }
    public static async pGuildLog(client: Client, script: string, message: string, err?: Error) {
        return pGuildLog(client, script, message, err);
    }
    public static async pUserLog(client: Client, script: string, message: string, err?: Error) {
        return pUserLog(client, script, message, err);
    }
    public static async consoleLog(client: Client, message: string) {
        return consoleLog(client, message);
    }
    public static async eventLog(client: Client, content: MessageEmbed) {
        return eventLog(client, content);
    }
    public static async tellLog(client: Client, sender: User, reciever: User, message: Message | MessageEmbed) {
        return tellLog(client, sender, reciever, message);
    }
    public static async latencyCheck(message: Message) {
        return latencyCheck(message);
    }
    public static async raspberryLog(client: Client) {
        if (client.user.id == PinguLibrary.Clients.BetaID) return;

        let raspberryLogChannel = this.getChannel(client, this.SavedServers.PinguSupport(client).id, 'raspberry-log-🍇');
        if (!raspberryLogChannel) return this.DanhoDM(client, `Couldn't get #raspberry-log-🍇 channel in Pingu Support, https://discord.gg/gbxRV4Ekvh`)

        return raspberryLogChannel.send(`Pulled version ${config.version} from Github`);
    }
    //#endregion

    public static getEmote(client: Client, name: string, emoteGuild: Guild) {
        if (!client || !name || !emoteGuild) return '😵';

        let emote = client.guilds.cache.find(g => g.id == emoteGuild.id).emojis.cache.find(e => e.name == name);
        if (emote) return emote;
        PinguLibrary.errorLog(client, `Unable to find Emote **${name}** from ${emoteGuild.name}`);
        return '😵';
    }
    public static getImage(script: string, imageName: string) {
        return `./embedImages/${script}_${imageName}.png`;
    }
    public static async DBExecute(client: Client, callback: (mongoose: typeof import('mongoose')) => void) {
        try {
            await mongoose.connect(`mongodb+srv://Pingu:${config.mongoPass}@pingudb.kh2uq.mongodb.net/PinguDB?retryWrites=true&w=majority`, {
                useNewUrlParser: true,
                useUnifiedTopology: true
            });
            await callback(mongoose);
        } catch (err) { PinguLibrary.errorLog(client, 'Mongo error', null, new Error(err)); }
        //finally { mongoose.connection.close(); }
    }
    public static BlankEmbedField(inline = false) {
        return new EmbedField('\u200B', '\u200B', inline)
    }
}
export {PinguLibrary};