import { MessageEmbed, Guild, BitFieldResolvable, PermissionString, User, GuildAuditLogsAction, Collection } from 'discord.js';
import { DiscordPermissions } from '../helpers';

export class PinguEvents {
    public static Colors = {
        Create: `#18f151`,
        Update: `#ddfa00`,
        Delete: `#db1108`
    };
    public static noAuditLog = `**No Audit Log Permissions**`;
    public static LoggedCache: MessageEmbed[];

    public static async GetAuditLogs(guild: Guild, type: GuildAuditLogsAction, key?: string, target: User = null, seconds: number = 1) {
        if (!guild.me.hasPermission(DiscordPermissions.VIEW_AUDIT_LOG as BitFieldResolvable<PermissionString>))
            return this.noAuditLog;

        let now = new Date(Date.now());
        let logs = (await guild.fetchAuditLogs({ type }));
        now.setSeconds(now.getSeconds() - seconds);
        let filteredLogs = logs.entries.filter(e => e.createdTimestamp > now.getTime());

        try { return key ? filteredLogs.find(e => e.changes.find(change => change.key == key) && (target ? e.target == target : true)).executor.tag : filteredLogs.first().executor.tag; }
        catch (err) { if (err.message == `Cannot read property 'executor' of undefined`) return this.noAuditLog; }
    }
    public static UnknownUpdate(old: object, current: object) {
        let oldArr = Object.keys(old);
        let currentArr = Object.keys(current);

        for (var i = 0; i < currentArr.length || i < oldArr.length; i++) {
            if (currentArr[i] != oldArr[i])
                return PinguEvents.SetDescriptionValues('Unknown', oldArr[i], currentArr[i]);
        }

        return null;
    }

    public static SetDescription(type: string, description: string) {
        return `[**${type}**]\n\n${description}`;
    }
    public static SetRemove(type: string, oldValue: object, newValue: object, SetString: string, RemoveString: string, descriptionMethod: (type: string, oldValue: object, newValue: object) => string) {
        return newValue && !oldValue ? PinguEvents.SetDescription(type, SetString) :
            !newValue && oldValue ? PinguEvents.SetDescription(type, RemoveString) : descriptionMethod(type, oldValue, newValue);
    }
    public static SetDescriptionValues(type: string, oldValue: any, newValue: any) {
        return PinguEvents.SetDescription(type, `Old: ${oldValue}\n\nNew: ${newValue}`)
    }
    public static SetDescriptionValuesLink(type: string, oldValue: any, newValue: any) {
        return PinguEvents.SetDescription(type, `[Old](${oldValue})\n[New](${newValue})`)
    }
    /**@param type [**${type}**]
     * @param preArr Previous array
     * @param newArr Current array
     * @param callback pre/new.find(i => callback(i, preItem/newItem))*/
    public static GoThroughArrays<T>(type: string, preArr: T[], newArr: T[], callback: (item: T, loopItem: T) => T) {
        let updateMessage = `[**${type}**] `;
        let added = GoThroguhArray(newArr, preArr);
        let removed = GoThroguhArray(preArr, newArr);

        if (added.length == 0 && removed.length != 0) return updateMessage += removed.join(`, `).substring(removed.join(', ').length - 2);
        else if (removed.length == 0 && added.length != 0) return updateMessage += added.join(`, `).substring(added.join(', ').length - 2);
        return updateMessage += `Unable to find out what changed!`;

        function GoThroguhArray(cycleArr: T[], otherCycleArr: T[]) {
            let result = new Array<T>();

            for (var item of cycleArr) {
                let old = otherCycleArr.find(i => callback(i, item));
                if (!old) result.push(item);
            }
            return result;
        }
    }
    public static GoThroughObjectArray<T>(type: string, preArr: T[], newArr: T[]) {
        let updateMessage = `[**${type}**]\n`;
        let changes = new Collection<string, string>();

        if (preArr.length > newArr.length) return updateMessage += `Removed ${type.toLowerCase()}`;
        else if (newArr.length > preArr.length) return updateMessage += `Added new ${type.toLowerCase()}`;

        for (var i = 0; i < newArr.length; i++) {
            let newKeys = Object.keys(newArr[i]);
            let preKeys = Object.keys(preArr[i]);

            newKeys.forEach(key => {
                if (newArr[key] == preArr[key]) return;
                else if (!preArr[key]) changes.set(key, `__Added__: ${newArr[key]}`);
                else changes.set(key, `__Changed__: **${preArr[key]}** => **${newArr[key]}**`)
            });
            preKeys.forEach(key => {
                if (changes.get(key) || preKeys[key] == newKeys[key]) return
                else if (!newArr[key]) changes.set(key, `__Removed__: ${preArr[key]}`);
            });
        }

        changes.keyArray().forEach(key => updateMessage += `**${key}**: ${changes.get(key)}\n`)
        return updateMessage;
    }
}
