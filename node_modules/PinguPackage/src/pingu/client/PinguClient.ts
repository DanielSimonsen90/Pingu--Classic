import { ActivityOptions, ActivityType, Client, ClientEvents, ClientOptions, Collection, User, VoiceChannel } from "discord.js";
import * as fs from 'fs';

export const Clients = {
    PinguID: '562176550674366464',
    BetaID: '778288722055659520'
}
export function ToPinguClient(client: Client) {
    return client as PinguClient;
}

import { errorLog, DanhoDM, raspberryLog, SavedServers } from '../library/PinguLibrary';
import { PinguUser } from '../user/PinguUser';
import { PinguGuild } from '../guild/PinguGuild';

import { PinguCommand, PinguEvent, PinguClientEvents } from '../handlers';

import { IConfigRequirements, Config } from '../../helpers/Config';

export class PinguClient extends Client {
    //Statics
    public static Clients = Clients;
    public static ToPinguClient(client: Client) { return ToPinguClient(client); }

    constructor(config: IConfigRequirements, subscribedEvents: [keyof ClientEvents], commandsPath?: string, evensPath?: string, options?: ClientOptions) {
        super(options);

        this.config = new Config(config);
        this.subscribedEvents = subscribedEvents.map(v => 
            v == 'ready' ? 'onready' : 
            v == 'debug' ? 'ondebug' : 
            v
        ) as [keyof PinguClientEvents];

        if (commandsPath) this.HandlePath(commandsPath, 'command');
        if (evensPath) this.HandlePath(evensPath, 'event');
    }

    //Public properties
    public commands = new Collection<string, PinguCommand>();
    public events = new Collection<string, PinguEvent<keyof PinguClientEvents>>();
    public DefaultEmbedColor = 3447003;
    public DefaultPrefix: string;
    public subscribedEvents: [keyof PinguClientEvents];

    //Pubic methods
    public setActivity(options?: ActivityOptions) {
        if (options) return this.user.setActivity(options);

        class Activity {
            constructor(text: string, type: ActivityType) {
                this.text = text;
                this.type = type;
            }
            public text: string
            public type: ActivityType
        }

        internalSetActivity(this);
        if (this.config.updateStats) UpdateStats(this);

        setInterval(internalSetActivity, 86400000);
        try { setInterval(UpdateStats, 86400000) }
        catch (err) { errorLog(this, `Updating Stats failed`, null, err); }

        function internalSetActivity(client: PinguClient) {
            let date = {
                day: new Date(Date.now()).getDate(),
                month: new Date(Date.now()).getMonth() + 1,
                year: new Date(Date.now()).getFullYear()
            };

            var activity = new Activity('your screams for', 'LISTENING');
            if (!client.isLive) activity = new Activity('Danho cry over bad code', 'WATCHING');

            if (date.month == 12)
                activity = date.day < 26 ?
                    new Activity('Jingle Bells...', 'LISTENING') :
                    new Activity('fireworks go boom', 'WATCHING');
            else if (date.month == 5)
                activity =
                    date.day == 3 ? new Activity(`Danho's birthday wishes`, 'LISTENING') :
                        date.day == 4 ? new Activity('Star Wars', 'WATCHING') : null;

            if (!activity) activity = new Activity('your screams for', 'LISTENING');

            client.user.setActivity(activity.text + ` ${client.DefaultPrefix}help`, { type: activity.type })
            raspberryLog(client);
        }
        async function UpdateStats(client: PinguClient) {
            let getChannel = (client: Client, channelID: string) => SavedServers.PinguSupport(client).channels.cache.get(channelID) as VoiceChannel;
            let channels = [
                getChannel(client, '799596588859129887'), //Servers
                getChannel(client, '799597092107583528'), //Users
                getChannel(client, '799597689792757771'), //Daily Leader
                getChannel(client, '799598372217683978'), //Server of the Day
                getChannel(client, '799598024971518002'), //User of the Day
                getChannel(client, '799598765187137537')  //Most known member
            ]
            let setName = async (channel: VoiceChannel) => {
                let getInfo = async (channel: VoiceChannel) => {
                    switch (channel.id) {
                        case '799596588859129887': return getServersInfo(); //Servers
                        case '799597092107583528': return getUsersInfo(); //Users
                        case '799597689792757771': return await getDailyLeader(); //Daily Leader
                        case '799598372217683978': return getRandomServer(); //Server of the Day
                        case '799598024971518002': return getRandomUser(); //User of the Day
                        case '799598765187137537': return getMostKnownUser(); //Most known User
                        default: errorLog(client, `ID of ${channel.name} was not recognized!`); return "No Info";
                    }

                    function getServersInfo() {
                        return client.guilds.cache.size.toString();
                    }
                    function getUsersInfo() {
                        return client.users.cache.size.toString();
                    }
                    async function getDailyLeader() {
                        try {
                            let pUser = (await PinguUser.GetPUsers()).sort((a, b) => {
                                try { return b.daily.streak - a.daily.streak }
                                catch (err) { errorLog(client, `unable to get daily streak difference between ${a.tag} and ${b.tag}`, null, err); }

                            })[0];
                            return `${pUser.tag} #${pUser.daily.streak}`;
                        }
                        catch (err) { errorLog(client, `Unable to get Daily Leader`, null, err); }
                    }
                    function getRandomServer() {
                        let availableGuilds = client.guilds.cache.array().map(g => ![
                            SavedServers.DanhoMisc(client).id,
                            SavedServers.PinguEmotes(client).id,
                            SavedServers.PinguSupport(client).id,
                        ].includes(g.id) && g.name != undefined && g).filter(v => v);
                        let index = Math.floor(Math.random() * availableGuilds.length);
                        return availableGuilds[index].name;
                    }
                    function getRandomUser() {
                        let availableUsers = client.users.cache.array().map(u => !u.bot && u).filter(v => v);
                        return availableUsers[Math.floor(Math.random() * availableUsers.length)].tag;
                    }
                    function getMostKnownUser() {
                        let Users = new Collection<User, number>();

                        client.guilds.cache.forEach(guild => {
                            guild.members.cache.forEach(gm => {
                                let { user } = gm;
                                if (user.bot) return;

                                if (!Users.has(user))
                                    return Users.set(user, 1);

                                Users.set(user, Users.get(user) + 1);
                            })
                        });

                        let sorted = Users.sort((a, b) => b - a);
                        let strings = sorted.filter((v, u) => sorted.first() == v).map((v, u) => `${u.tag} | #${v}`);
                        return strings[Math.floor(Math.random() * strings.length)];
                    }
                };
                let channelName = channel.name.split(':')[0];
                let info = await getInfo(channel);
                let newName = `${channelName}: ${info}`;
                if (channel.name == newName) return;
                return channel.setName(newName);
            }

            for (var channel of channels) setName(channel);
        }
    }
    public get isLive() { return this.user.id == PinguClient.Clients.PinguID }
    public toPClient(pGuild: PinguGuild) {
        return pGuild.clients.find(c => c && c._id == this.user.id);
    }

    private handleEvent<eventType extends keyof PinguClientEvents>(caller: eventType, ...args: PinguClientEvents[eventType]) {
        if (this.subscribedEvents.includes(caller)) 
            PinguEvent.HandleEvent(caller, this, this.events.get(caller).path, ...args as PinguClientEvents[eventType]);
        return this;
    }

    private getEventParams<eventType extends keyof PinguClientEvents>(client: PinguClient, caller: eventType, ...args: PinguClientEvents[eventType]) {
        switch (caller) {
            case 'ready': case 'onready': return { caller: (caller == 'onready' ? 'ready' : caller) as eventType, args: [client] as PinguClientEvents[eventType] }
            case 'debug': case 'ondebug': return { caller: (caller == 'ondebug' ? 'debug' : caller) as eventType, args: [client] as PinguClientEvents[eventType] }
            default: return { caller: caller as eventType, args: args as PinguClientEvents[eventType] };
        }
    }

    async login(token?: string){
        let res = await super.login(token);        
        this.DefaultPrefix = this.isLive || !this.config.BetaPrefix ? this.config.Prefix : this.config.BetaPrefix;
        return res;
    }

    //Private properties
    public config: Config;

    //Private methods
    private HandlePath(path: string, type: 'command' | 'event') {
        let collection = fs.readdirSync(path);
        for (var file of collection) {
            try {
                if (file.endsWith(`.js`)) {
                    let module = require(`../../../../../${path}/${file}`);
                    module.path = `${path.substring(1, path.length)}/${file}`;

                    if (type == 'event') {
                        if (!module.name || !this.subscribedEvents.includes(module.name as keyof PinguClientEvents)) continue;

                        const type = module.name as keyof PinguClientEvents
                        const event = module as PinguEvent<typeof type>;

                        this.events.set(event.name, event);
                        // this.on(event.name as keyof ClientEvents, (...args) => this.handleEvent(event.name as keyof ClientEvents, ...args));

                        let { caller } = this.getEventParams(this, event.name); //Get original event
                        this.on(caller as keyof ClientEvents, (...params) => { //On original event
                            let pinguEventStuff = this.getEventParams(this, event.name, ...params); //Get Pingu event
                            this.handleEvent(event.name, ...pinguEventStuff.args) //Handle as Pingu event
                        })
                    }
                    else if (type == 'command') this.commands.set(module.name, module as PinguCommand);
                    else errorLog(this, `"${type}" was not recognized!`);
                }
                else if (file.endsWith('.png') || file.toLowerCase().includes('archived')) continue;
                else this.HandlePath(`${path}/${file}`, type);
            } catch (err) {
                DanhoDM(`"${file}" threw an exception:\n${err.message}\n${err.stack}\n`)
            }
        }
    }
}