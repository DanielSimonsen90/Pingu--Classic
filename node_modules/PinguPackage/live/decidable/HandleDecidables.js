"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandleDecidables = void 0;
const discord_js_1 = require("discord.js");
const config_1 = require("./config");
const Decidable_1 = require("./items/Decidable");
const items_1 = require("./items");
const PinguGuild_1 = require("../pingu/guild/PinguGuild");
const PRole_1 = require("../database/json/PRole");
const PChannel_1 = require("../database/json/PChannel");
const PGuildMember_1 = require("../database/json/PGuildMember");
const PinguLibrary_1 = require("../pingu/library/PinguLibrary");
const TimeLeftObject_1 = require("../helpers/TimeLeftObject");
const ms_1 = require("ms");
function SetConfigObjects(config) {
    const { giveawayConfig, pollConfig, suggestionConfig, themeConfig } = config;
    const giveawayObj = {
        firstTimeExecuted: giveawayConfig.firstTimeExecuted,
        channel: giveawayConfig.channel,
        hostRole: giveawayConfig.hostRole,
        winnerRole: giveawayConfig.winnerRole,
        collection: giveawayConfig.giveaways,
        allowSameWinner: giveawayConfig.allowSameWinner,
        staffRoleType: 'Giveaway Host'
    };
    const pollObj = {
        firstTimeExecuted: pollConfig.firstTimeExecuted,
        channel: pollConfig.channel,
        hostRole: pollConfig.pollRole,
        collection: pollConfig.polls,
        staffRoleType: 'Poll Host'
    };
    const suggestionsObj = {
        firstTimeExecuted: suggestionConfig.firstTimeExecuted,
        channel: suggestionConfig.channel,
        hostRole: suggestionConfig.managerRole,
        collection: suggestionConfig.suggestions,
        staffRoleType: 'Suggestion Manager'
    };
    const themeMap = {
        firstTimeExecuted: themeConfig.firstTimeExecuted,
        channel: themeConfig.channel,
        winnerRole: themeConfig.winnerRole,
        hostRole: themeConfig.hostRole,
        collection: themeConfig.themes,
        allowSameWinner: themeConfig.allowSameWinner,
        ignoreLastWins: themeConfig.ignoreLastWins,
        staffRoleType: 'Theme Host'
    };
    return Configs = new Map([
        [giveawayConfig, giveawayObj],
        [pollConfig, pollObj],
        [suggestionConfig, suggestionsObj],
        [themeConfig, themeMap]
    ]);
}
let Configs;
function HandleDecidables(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { client, message, args, pGuild, pGuildClient, decidablesType, config, reactionEmojis } = params;
        const { guild, author, content, mentions, member } = message;
        const { send } = message.channel;
        const { firstTimeExecuted, channel } = config;
        const reroll = () => ['Giveaway', 'Theme'].includes(decidablesType) && args[0] == 'reroll';
        //A decidables command must have a Pingu Guild registered
        if (!pGuild) {
            yield PinguLibrary_1.errorLog(client, `Unable to host ${decidablesType.toLowerCase()} for ${message.guild.name}, as I couldn't get their PinguGuild!`);
            return send(`I couldn't get your PinguGuild, so I can't host the ${decidablesType.toLowerCase()} for you!`);
        }
        const decidablesConfig = pGuild.settings.config.decidables;
        SetConfigObjects(decidablesConfig);
        let permCheck = yield PermissionCheckDecidable(params);
        if (permCheck != PinguLibrary_1.PermissionGranted)
            return send(permCheck);
        //Is user trying to host?
        if (firstTimeExecuted || args[0] == 'setup')
            return FirstTimeExecuted(params);
        else if (args[0] == 'list')
            return ListDecidables(params, Configs.get(config).collection);
        if (decidablesType != 'Suggestion') {
            var time = args[0];
            if (reroll())
                args.shift();
            else if (isGiveawayType(decidablesType)) {
                var winners = 1;
                if (args[0].endsWith('w') && !isNaN(parseInt(args[0].substring(0, args[0].length - 1)))) {
                    let winnerString = args.shift();
                    winners = parseInt(winnerString.substring(0, winnerString.length));
                }
            }
        }
        let decidablesChannel = guild.channels.cache.find(c => [c.id, c.name].includes(args[0]) || c == mentions.channels.first());
        if (decidablesChannel)
            args.shift();
        else
            decidablesChannel = (args[0] != 'reroll' ? guild.channels.cache.get(channel === null || channel === void 0 ? void 0 : channel._id) || message.channel : message.channel);
        const users = new Map([[author, ['VIEW_CHANNEL']], [client.user, ['SEND_MESSAGES', 'ADD_REACTIONS']]]);
        for (const [u, perms] of users) {
            let channelPerms = PinguLibrary_1.PermissionCheck({ author: u, client, content, channel: decidablesChannel }, ...perms);
            if (channelPerms != PinguLibrary_1.PermissionGranted)
                return send(channelPerms);
        }
        let value = args.join(' ');
        let mention = mentions.users.first();
        if (value.includes('<@'))
            value = value.replace(/<@!*\d{18}>/, guild.member(mention) ? guild.member(mention).displayName : mention.username);
        if ('Suggestion' != decidablesType)
            var endsAt = new Date(Date.now() + ms_1.default(time));
        let embed = new discord_js_1.MessageEmbed({
            title: 'Suggestion' == decidablesType ? 'Suggestion' : value,
            color: pGuildClient.embedColor,
            description: isGiveawayType(decidablesType) ? (`React with ${reactionEmojis[0]} to enter!\n` +
                `Winners: **${winners}**\n` +
                `Ends in: ${new TimeLeftObject_1.default(new Date(Date.now()), endsAt).toString()}\n` +
                `Hosted by ${message.author}`) : decidablesType == 'Poll' ? (`Brought to you by <@${message.author.id}>\n` +
                `Time left: ${new TimeLeftObject_1.default(new Date(Date.now()), endsAt).toString()}`) : value,
            footer: { text: decidablesType == 'Suggestion' ? `This suggestion is currently Undecided` : `Ends at` },
            timestamp: decidablesType != 'Suggestion' ? endsAt : null
        });
        if (reroll()) {
            let sent = yield send(`Rerolling ${decidablesType.toLowerCase()}...`);
            return Reroll(params, sent, embed, Configs.get(config).collection.find(d => d._id == value));
        }
        else if (message.channel.id == decidablesChannel.id &&
            PinguLibrary_1.PermissionCheck({ author: client.user, client, channel: decidablesChannel }, 'MANAGE_MESSAGES') == PinguLibrary_1.PermissionGranted)
            message.delete();
        else
            send(`Announcing the ${decidablesType.toLowerCase()} in ${decidablesChannel} now!`).then(s => s.delete({ timeout: ms_1.default('5s') }));
        const sent = yield send(`New ${decidablesType}!`, embed);
        reactionEmojis.forEach(e => sent.react(e));
        PinguLibrary_1.consoleLog(client, `${author} hosted ${decidablesType} in ${decidablesChannel} (${decidablesChannel.name}), ${guild}`);
        let decidable = new Decidable_1.default(value, sent.id, new PGuildMember_1.default(member), decidablesChannel, endsAt);
        AddDecidableToPGuilds(params, decidable);
        if (decidablesType == 'Suggestion')
            return sent;
        let interval = setInterval(() => function updateTimer() {
            sent.edit(sent.embeds[0].setDescription(isGiveawayType(decidablesType) ? (`React with ${reactionEmojis[0]} to enter!\n` +
                `Winners: **${winners}**\n` +
                `Ends in: ${new TimeLeftObject_1.default(new Date(Date.now()), endsAt).toString()}\n` +
                `Hosted by <@${decidable.author._id}>`) : decidablesType == 'Poll' ? (`Brought to you by <@${decidable.author._id}>\n` +
                `Time left: ${new TimeLeftObject_1.default(new Date(Date.now()), endsAt).toString()}`) : sent.embeds[0].description)).catch(err => {
                PinguLibrary_1.errorLog(client, `Updating ${decidablesType.toLowerCase()} timer`, content, err);
                author.send(`I had an issue updating the ${decidablesType.toLowerCase()} message, so your ${decidablesType.toLowerCase()} might be broken!`);
            });
        }, ms_1.default('5s'));
        setTimeout(() => onTimeFinished(sent, value, winners, embed, decidable, interval, params, null), ms_1.default(time));
    });
}
exports.HandleDecidables = HandleDecidables;
function PermissionCheckDecidable(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { client, message, config, args, decidablesType, pGuild } = params;
        const { firstTimeExecuted } = config;
        let { hostRole } = Configs.get(config);
        //If executed for the first time or a sub command is used, no need to validate if args are okay
        if (firstTimeExecuted || ["reroll", "setup", "list"].includes(args[0]))
            return PinguLibrary_1.PermissionGranted;
        //!args[0] && !args[1]: [time, ...title]
        else if (args.length < 2)
            return `You didn't give me enough arguments!`;
        yield (function CheckRoleUpdates() {
            return __awaiter(this, void 0, void 0, function* () {
                let hostPRole = Configs.get(config).hostRole;
                let winnerPRole = Configs.get(config).winnerRole;
                const CheckRole = (pRole) => pRole && message.guild.roles.fetch(pRole._id);
                const [hostRole, winnerRole] = yield Promise.all([
                    CheckRole(hostPRole),
                    CheckRole(winnerPRole)
                ]);
                const noWinnerRole = !winnerRole && winnerPRole != undefined;
                const noHostRole = !hostRole && hostPRole != undefined;
                const winnerNameChanged = !noWinnerRole && winnerRole.name != winnerPRole.name;
                const hostNameChanged = !noHostRole && hostRole.name != hostPRole.name;
                //Any condition is true
                if ([noWinnerRole, noHostRole, winnerNameChanged, hostNameChanged].some(v => v)) {
                    yield UpdatePGuild(client, pGuild, decidablesType, `${decidablesType} role${decidablesType == 'Giveaway' ? 's' : ''} updated.`);
                }
            });
        })();
        if (decidablesType == 'Suggestion')
            return PinguLibrary_1.PermissionGranted;
        const { member } = message;
        //Not admin nor have host role
        if (!member.hasPermission('ADMINISTRATOR') && hostRole && !member.roles.cache.has(hostRole._id)) {
            return "You don't have `Administrator` permissions" + (hostRole ? ` or the \`${hostRole.name}\` role` : "" + "!");
        }
        const arg0 = args[0];
        const arg0Parsed = parseInt(arg0.substring(1, arg0.length - 1));
        //Winner specified
        if (decidablesType == 'Giveaway' && arg0.endsWith('w') && !isNaN(arg0Parsed)) {
            args.shift();
        }
        else if (arg0.endsWith('s') && arg0Parsed < 30)
            return `Please specify a time higher than 29s!`;
        else if (!ms_1.default(arg0))
            return `Please provide a valid time!`;
        else if (!isNaN(arg0Parsed))
            args[0] += "m"; //No s/m/h provided, treat as minutes
        return PinguLibrary_1.PermissionGranted;
    });
}
function FirstTimeExecuted(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { client, args, message, decidablesType, pGuild, config } = params;
        const { send } = message.channel;
        if (args[0] != 'setup')
            message.channel.send(`**Hold on fella!**\nWe need to get ${message.guild.name} set up first!`);
        const hasAllArguments = yield HasAllArguments();
        if (hasAllArguments)
            return;
        const collector = message.channel.createMessageCollector(m => m.author.id == message.author.id);
        let decidablesChannelName = decidablesType.toLowerCase();
        const { staffRoleType } = Configs.get(config);
        send(`Firstly, ${Find('Role', staffRoleType, 'Exists', message)}`);
        collector.on('collect', function onCollect(input) {
            return __asyncGenerator(this, arguments, function* onCollect_1() {
                const userInput = input;
                //hostRole Tag
                yield yield __await(send(Find('Role', staffRoleType, 'Tag', userInput)));
                //hostRole Find
                let staffRoleResult = Find('Role', staffRoleType, 'Find', userInput);
                let staffRole = NullMakeValue('Role', staffRoleResult);
                //winnerRole Exists
                if (['Giveaway', 'Theme'].includes(decidablesType)) {
                    yield yield __await(send(Find('Role', `${decidablesType} Winner`, 'Exists', userInput)));
                    //winnerRole Find
                    let winnerRoleResult = Find('Role', `${decidablesType} Winner`, 'Find', userInput);
                    var winnerRole = NullMakeValue('Role', winnerRoleResult);
                }
                //channel Tag
                yield yield __await(send(Find('Channel', decidablesChannelName, 'Exists', userInput)));
                //channel Find
                let channelResult = Find('Channel', decidablesChannelName, 'Find', userInput);
                let channel = NullMakeValue('Channel', channelResult);
                //Poll & Suggestion finished
                let goodToGo = { staffRole, channel };
                if (!['Giveaway', 'Theme'].includes(decidablesType))
                    return yield __await(GoodToGo(goodToGo));
                //allowSameWinner Ask
                yield yield __await(send(`Alright last thing, should I allow same winners? (A user winning a ${decidablesType.toLowerCase()} can't win the next one, if you say no!)`));
                //allowSameWinner Process
                let allowSameWinner = userInput.content.toLowerCase() == 'yes';
                //Giveaway finished
                if ('Giveaway' == decidablesType)
                    return yield __await(GoodToGo(goodToGo = Object.assign(Object.assign({}, goodToGo), { winnerRole, allowSameWinner })));
                //ignoreLastWins ask
                yield yield __await(send(`Okay last thing I promise- how many previous ${decidablesType.toLowerCase()}s' winners should I ignore?` +
                    `(If set to 2, the winners for the last 2 ${decidablesType.toLowerCase()}s will not be able to win the current one.) Default is 0`));
                //Theme finished
                return yield __await(GoodToGo(Object.assign(Object.assign({}, goodToGo), { ignoreLastWins: parseInt(userInput.content.toLowerCase()) || 0 })));
            });
        });
        collector.on('end', () => __awaiter(this, void 0, void 0, function* () {
            send(`Alright, you're all set!`);
            PinguLibrary_1.consoleLog(client, `"${message.guild.name}" successfully configured their ${decidablesType}Config.`);
            if (args[0] != 'setup')
                return HandleDecidables(params);
        }));
        function HasAllArguments() {
            return __awaiter(this, void 0, void 0, function* () {
                //   0        1         2            2        3        3       4         4         5           5
                //[setup, staffRole, channel || winnerRole, null || channel, null || sameWinner, null || ignoreLastWins]
                if (decidablesType == 'Giveaway' && args.length != 5)
                    return false; //Not enough arguments
                if (decidablesType == 'Theme' && args.length != 6)
                    return false; //Not enough arguments
                class T {
                }
                let find = (i, arg) => [i.id, i.name.toLowerCase(), i.toString().toLowerCase()].includes(arg) && i;
                let findRole = (argument) => argument == 'null' ? null : message.guild.roles.cache.find(r => find(r, argument) != null);
                let findChannel = (argument) => argument == 'null' ? null : message.guild.channels.cache.find(c => find(c, argument) && c.isText());
                let staffRole = findRole(args[1]);
                let channel = findChannel(args[decidablesType != 'Giveaway' && decidablesType != 'Theme' ? 2 : 3]);
                if (['Giveaway', 'Theme'].includes(decidablesType)) {
                    yield GoodToGo({
                        staffRole, channel,
                        winnerRole: findRole(args[2]),
                        allowSameWinner: ['yes', 'true'].includes(args[4].toLowerCase()),
                        ignoreLastWins: decidablesType == 'Theme' && !isNaN(parseInt(args[5])) ? parseInt(args[5]) : 0
                    });
                }
                else
                    yield GoodToGo({ staffRole, channel });
                message.channel.send("Setup done!");
                return true;
            });
        }
        function GoodToGo(params) {
            return __awaiter(this, void 0, void 0, function* () {
                let { channel, staffRole, allowSameWinner, winnerRole, ignoreLastWins } = params;
                const decidablesConfig = pGuild.settings.config.decidables;
                if (typeof staffRole == 'string' && staffRole == 'make')
                    staffRole = yield MakeRole(message.guild, staffRoleType);
                if (typeof channel == 'string' && channel == 'Make')
                    channel = yield MakeChannel(message.guild, decidablesChannelName);
                if (winnerRole && typeof winnerRole == 'string' && winnerRole == 'Make')
                    winnerRole = yield MakeRole(message.guild, "Giveaway Winner");
                const _firstTimeExecuted = false;
                const _channel = channel && channel != 'null' ? new PChannel_1.default(channel) : null;
                const _staffRole = staffRole && staffRole != 'null' ? new PRole_1.default(staffRole) : null;
                const _winnerRole = winnerRole && winnerRole != 'null' ? new PRole_1.default(winnerRole) : null;
                const basic = {
                    firstTimeExecuted: _firstTimeExecuted,
                    channel: _channel
                };
                const result = (function assignConfig() {
                    switch (decidablesType) {
                        case 'Giveaway': return decidablesConfig.giveawayConfig = new config_1.GiveawayConfig(Object.assign(Object.assign({}, basic), { hostRole: _staffRole, winnerRole: _winnerRole, giveaways: [], allowSameWinner }));
                        case 'Poll': return decidablesConfig.pollConfig = new config_1.PollConfig(Object.assign(Object.assign({}, basic), { pollRole: _staffRole, polls: [] }));
                        case 'Suggestion': return decidablesConfig.suggestionConfig = new config_1.SuggestionConfig(Object.assign(Object.assign({}, basic), { managerRole: _staffRole, suggestions: [] }));
                        case 'Theme': return decidablesConfig.themeConfig = new config_1.ThemeConfig(Object.assign(Object.assign({}, basic), { hostRole: _staffRole, winnerRole: _winnerRole, themes: [], allowSameWinner, ignoreLastWins }));
                    }
                })();
                yield UpdatePGuild(client, pGuild, decidablesType, `**${pGuild.name}**'s ${decidablesType}Config after setting it up.`);
                collector.stop('Setup done');
                const { author, member, guild } = message;
                PinguLibrary_1.AchievementCheck(client, {
                    user: author,
                    guildMember: member,
                    guild
                }, 'CHANNEL', decidablesType, [message.channel]);
                return result;
                function MakeRole(guild, name) {
                    return __awaiter(this, void 0, void 0, function* () {
                        return guild.roles.create({
                            data: { name },
                            reason: `Auto-created when setting up ${decidablesType.toLowerCase()}`
                        }).catch(err => {
                            PinguLibrary_1.errorLog(client, `Creating ${name} role`, message.content, err);
                            return null;
                        });
                    });
                }
                function MakeChannel(guild, name) {
                    return __awaiter(this, void 0, void 0, function* () {
                        return guild.channels.create(name, {
                            reason: `Auto-created when setting up ${decidablesType.toLowerCase()}`
                        }).catch(err => {
                            PinguLibrary_1.errorLog(client, `Creating ${name} channel`, message.content, err);
                            return null;
                        });
                    });
                }
            });
        }
        /***@returns Response to 'Exists' & 'Create', but returns id of type || "Make" || "undefined" as final result*/
        function Find(type, typeName, pinguResponse, userInput) {
            let response = userInput.content.toLowerCase();
            let typeResult = null;
            switch (pinguResponse) {
                case 'Exists': return `Do you have a **${typeName}** ${type.toLowerCase()}?`;
                case 'Tag': return response == 'yes' ?
                    `Please tag the ${type.toLowerCase()} or send the ${type.toLowerCase()} ID` :
                    response == 'no' ?
                        `Would you like a **${typeName}** ${type.toLowerCase()}?` :
                        null;
                case 'Find':
                    typeResult = type == 'Role' ?
                        (message.guild.roles.cache.find(r => [r.id, r.name.toLowerCase()].includes(response)) || userInput.mentions.roles.first()) :
                        (message.guild.channels.cache.find(c => [c.id, c.name.toLowerCase()].includes(response)) || userInput.mentions.channels.first());
                    if (typeResult)
                        send(`Okay, I found ${typeResult.name}`);
                    else if (response == 'yes') {
                        typeResult = 'Make';
                        send(`Okay, I'll make that...`);
                    }
                    else if (response == 'no') {
                        typeResult = 'undefined';
                        send(`Okay, I won't make that...`);
                    }
                    return typeResult.id;
            }
        }
        function NullMakeValue(type, result) {
            return !['null', 'Make'].includes(result) ? message.guild[`${type.toLowerCase()}s`].cache.get(result) : result;
        }
    });
}
function onTimeFinished(sent, value, winnersAllowed, embed, decidable, interval, params, previousWinners) {
    return __awaiter(this, void 0, void 0, function* () {
        clearInterval(interval);
        const { decidablesType, pGuild, client, reactionEmojis } = params;
        const decidablesConfig = pGuild.settings.config.decidables;
        decidable = yield (decidablesType == 'Poll' ?
            DecidePoll(decidable) :
            GetGiveawayWinner(decidablesType == 'Giveaway' ? decidable : decidable));
        SaveVerdictToPGuilds(params, decidable);
        PinguLibrary_1.consoleLog(client, `Updated ${decidablesType.toLowerCase()} "${decidable._id}" after timeout.`);
        function DecidePoll(poll) {
            return __awaiter(this, void 0, void 0, function* () {
                const { get } = sent.reactions.cache;
                poll = items_1.Poll.Decide(poll, get('üëç').count, get('üëé').count);
                sent.channel.send(`The poll of **${poll.value}**, voted **${poll.approved}**!`);
                PinguLibrary_1.consoleLog(client, `Poll, "${poll.value}" (${poll._id}) by ${poll.author.name}, voted ${poll.approved}.`);
                sent.edit(embed
                    .setTitle(`FINISHED! ${poll.value}`)
                    .setDescription(`Voting done! Final answer: ${poll.approved}\n` +
                    `**ID:** \`${poll._id}\``)
                    .setFooter(`Poll ended.`));
                return poll;
            });
        }
        function GetGiveawayWinner(decidable) {
            return __awaiter(this, void 0, void 0, function* () {
                const host = sent.guild.member(decidable.author._id);
                const { config, message } = params;
                const { guild } = message;
                const { winnerRole, allowSameWinner } = config;
                let winners = new Array();
                let reactedUsers = yield sent.reactions.cache.get(reactionEmojis[0]).users.fetch({
                    after: sent.createdAt.toString(),
                    before: new Date().toString()
                }).catch((err) => __awaiter(this, void 0, void 0, function* () {
                    PinguLibrary_1.errorLog(client, `Fetching ${reactionEmojis[0]} reaction from ${decidablesType.toLowerCase()}`, sent.content, err);
                    host.createDM().then(dm => dm.send(`Hi! I ran into an issue while finding a winner for your ${decidablesType.toLowerCase()} "${value}"... I've already contacted my developers!`).catch(err => null));
                    return null;
                }));
                let members = yield guild.members.fetch({ user: reactedUsers.array() });
                reactedUsers = reactedUsers.filter(u => {
                    if (u.bot)
                        return false;
                    const winnerRoleExists = winnerRole && true;
                    const userIsntWinner = winnerRole && !members.get(u.id).roles.cache.has(winnerRole._id);
                    const isTheme = decidablesType == 'Theme';
                    const themeConfig = isTheme && Configs.get(config);
                    const userIsntInPreviousWinners = themeConfig.collection
                        .filter((_, i, col) => col.length - i < themeConfig.ignoreLastWins)
                        .map(col => col.winners)
                        .some((_, __, col) => !col.reduce((arr, winners) => arr.concat(winners.map(pgm => pgm._id)), new Array()).includes(u.id));
                    return (allowSameWinner || winnerRoleExists && userIsntWinner) && isTheme ? userIsntInPreviousWinners : true;
                });
                for (let i = 0; i < winnersAllowed; i++) {
                    var winner = getWinner();
                    while (!winner || typeof winner != 'string' && previousWinners.map(gm => gm.id).includes(winner.id)) {
                        winner = getWinner();
                    }
                    if (typeof winner == 'string') {
                        winner = 'no one';
                        winners[i] = winner;
                    }
                    else {
                        winners[i] = guild.member(winner);
                        reactedUsers.delete(winner.id);
                    }
                }
                if (winner == 'no one' || !winners.length || !winners[0]) {
                    sent.edit(embed
                        .setTitle(`Unable to find a winner for "${value}"!`)
                        .setDescription(`**Winner:** __Winner not found!__\n` +
                        `**ID:** \`${decidable._id}\``)
                        .setFooter(`${decidablesType} ended.`));
                    sent.channel.send(`A winner to "**${value}**" couldn't be found!`);
                    return decidable;
                }
                let winnersString = winners.join(', ').replace(/,\s*$/, ' &');
                const winnerOrWinners = `Winner${winners.length > 1 ? 's' : ''}`;
                let announceMessage = yield sent.channel.send(`The ${winnerOrWinners.toLowerCase()} of **${value}** is no other than ${winnersString}! Congratulations!`);
                announceMessage.react(PinguLibrary_1.getEmote(client, 'hypers', PinguLibrary_1.SavedServers.get('Pingu Support')));
                RemovePreviousWinners(guild.members.cache.filter(m => m.roles.cache.has(winnerRole._id)).array());
                for (let i = 0; i < winners.length; i++) {
                    yield guild.member(winners[i]).roles.add(winnerRole._id)
                        .catch(err => {
                        PinguLibrary_1.errorLog(client, `Unable to give ${winners[i]} a ${decidablesType} "${guild}"'s ${decidablesType} Winner role, ${winnerRole.name} (${winnerRole._id})`, sent.content, err);
                        host.user.send(`I couldn't give ${winners[i]} a ${decidablesType} Winner role!`);
                    });
                }
                host.user.send(`${winnersString} won your ${decidablesType.toLowerCase()}, **${value}** in **${guild}**!\n${sent.url}`);
                sent.edit(embed
                    .setTitle(`${winnerOrWinners} of "${value}"!`)
                    .setDescription(`**${winnerOrWinners}:** ${winnersString}\n` +
                    `**Host:** ${host}\n` +
                    `**ID:** ${decidable._id}`)
                    .setFooter(`${decidablesType} ended.`)).catch(err => {
                    PinguLibrary_1.errorLog(client, `Editing the ${decidablesType} Message`, sent.content, err);
                    host.user.send(`I encountered an error while updating the ${decidablesType.toLowerCase()} embed...`);
                });
                yield UpdatePGuildWinners();
                return decidable;
                function getWinner() {
                    let winner = (function selectWinner() {
                        if (!reactedUsers.size)
                            return `A winner couldn't be found!`;
                        let winner = reactedUsers.array()[Math.floor(Math.random() * reactedUsers.size)];
                        if (!winnerRole)
                            return winner;
                        else if (guild.member(winner).roles.cache.has(winnerRole._id))
                            return allowSameWinner ? winner : null;
                        return winner;
                    })();
                    if (typeof winner == 'string')
                        return winner;
                    if (!winnerRole)
                        message.author.send(`I couldn't find a ${decidablesType} Winner(s) role!\nI have selected a random winner from the members who reacted.`);
                    return winners.includes(guild.member(winner)) ? null : winner;
                }
                function RemovePreviousWinners(previousWinners) {
                    for (const winner of previousWinners) {
                        winner.roles.remove(winnerRole._id);
                    }
                }
                function UpdatePGuildWinners() {
                    return __awaiter(this, void 0, void 0, function* () {
                        for (const winner of winners) {
                            decidable.winners.push(new PGuildMember_1.default(guild.member(winner)));
                        }
                    });
                }
            });
        }
    });
}
function ListDecidables(params, collection) {
    return __awaiter(this, void 0, void 0, function* () {
        const { pGuild, listEmojis, decidablesType, message, client, pGuildClient } = params;
        const { send } = message.channel;
        let embeds = CreateEmbeds(false), embedIndex = 0;
        if (!decidablesType.length || !embeds.length)
            return send(`There are no ${decidablesType.toLowerCase()}s saved!`);
        var sent = yield send(embeds[embedIndex]);
        listEmojis.forEach(e => sent.react(e));
        const collector = sent.createReactionCollector((r, u) => listEmojis.includes(r.emoji.name) && u.id == message.author.id, { time: ms_1.default('20s') });
        collector.on('end', (collected) => __awaiter(this, void 0, void 0, function* () {
            if (!collected.map(r => r.emoji.name).includes('üõë')) {
                yield sent.delete();
                send(`Stopped showing ${decidablesType.toLowerCase()}s.`).then(s => s.delete({ timeout: ms_1.default('5s') }));
            }
        }));
        collector.on('collect', (reaction) => __awaiter(this, void 0, void 0, function* () {
            const getEmbedDecidable = (embed) => collection.find(d => {
                const sentences = embed.description.split('\n');
                const idSentence = sentences[sentences.length - 1];
                const id = idSentence.split(' ')[1];
                return d._id == id;
            });
            const onArrowLeft = () => __awaiter(this, void 0, void 0, function* () { return direction(-1); });
            const onBin = () => __awaiter(this, void 0, void 0, function* () { return direction(0); });
            const onArrowRight = () => __awaiter(this, void 0, void 0, function* () { return direction(1); });
            const onStop = () => __awaiter(this, void 0, void 0, function* () { return collector.stop('Requested by author'); });
            collector.resetTimer();
            let embedToSend = yield (function HandleEmojiName() {
                return __awaiter(this, void 0, void 0, function* () {
                    switch (reaction.emoji.name) {
                        case '‚¨ÖÔ∏è': return onArrowLeft();
                        case 'üëç':
                        case 'üëé': return onVerdict(reaction.emoji.name == 'üëç');
                        case 'üóëÔ∏è': return onBin();
                        case '‚û°Ô∏è': return onArrowRight();
                        case 'üõë': return onStop();
                        default: return onDefault();
                    }
                });
            })();
            if (!collection.length || !embedToSend) {
                send(`No more ${decidablesType.toLowerCase()}s saved!`);
                return onStop();
            }
            sent.edit(embedToSend);
            sent.reactions.cache.get(reaction.emoji.name).users.remove(message.author);
            function onVerdict(approved) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (decidablesType != 'Suggestion')
                        return embeds[embedIndex];
                    collection = yield Decide(params, approved, getEmbedDecidable(embeds[embedIndex]), message.member);
                    CreateEmbeds(true);
                    return direction(1);
                });
            }
            function onDefault() {
                return __awaiter(this, void 0, void 0, function* () {
                    PinguLibrary_1.errorLog(client, `${decidablesType.toLowerCase()}, ListDecidables(), collector.on(), default case: ${reaction.emoji.name}`, message.content);
                    return reaction.message.embeds[0];
                });
            }
            function direction(i) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!embeds)
                        return null;
                    embedIndex += i;
                    if (embedIndex <= 1) {
                        embedIndex = embeds.length - 1;
                        i = -1;
                    }
                    else if (embedIndex >= embeds.length) {
                        embedIndex = 0;
                        i = 1;
                    }
                    return i == 0 ? DeleteDecidable(embeds[embedIndex]) : embeds[embedIndex];
                });
            }
            function DeleteDecidable(embed) {
                return __awaiter(this, void 0, void 0, function* () {
                    let decidable = getEmbedDecidable(embed);
                    collection = yield RemoveDecidables(message, pGuild, decidablesType, [decidable]);
                    embeds = CreateEmbeds(true);
                    return !collection.includes(decidable) ?
                        ExpressDeletionSuccessful('‚úÖ', 1) :
                        ExpressDeletionSuccessful('‚ùå', -1);
                    function ExpressDeletionSuccessful(emote, index) {
                        return __awaiter(this, void 0, void 0, function* () {
                            const reaction = yield sent.react(emote);
                            yield new Promise(resolve => setTimeout(() => resolve(sent.reactions.cache.get(reaction.emoji.id).remove()), 1500));
                            return direction(index);
                        });
                    }
                });
            }
        }));
        function CreateEmbeds(autoCalled) {
            if (!collection.length)
                return null;
            let embeds = new Array(), toRemove = new Array();
            const createGiveawayEmbed = (g) => new discord_js_1.MessageEmbed({
                description: [
                    `**__Winner${g.winners.length > 1 ? 's' : ''}__**`,
                    g.winners.map(pg => `<@${pg._id}>`).join(', '), "",
                    `**Hosted by <@${g.author._id}>**`, "",
                    `**ID:** \`${g._id}\``
                ].join('\n')
            });
            const createPollEmbed = (p) => new discord_js_1.MessageEmbed({
                description: [
                    `**Verdict:** ${p.approved == 'Approved' ? 'üëç' : p.approved == 'Denied' ? 'üëé' : 'ü§∑‚Äç‚ôÇÔ∏è'}\n`,
                    `**Hosted by <@${p.author._id}>**\n`,
                    `**ID:** \`${p._id}\``
                ].join('\n')
            });
            const createSuggestionEmbed = (s) => new discord_js_1.MessageEmbed({
                description: [
                    `**Verdict:** ${s.approved == 'Approved' ? 'üëç' : s.approved == 'Denied' ? 'üëé' : 'ü§∑‚Äç‚ôÇÔ∏è'}\n`,
                    `**Suggested by <@${s.author._id}>**\n`,
                    s.approved != 'Undecided' ? `**Decided by <@${s.decidedBy._id}>**` : "",
                    `ID: ${s._id}`
                ].join('\n')
            });
            const createDecidableEmbed = new Map([
                ['Giveaway', createGiveawayEmbed],
                ['Poll', createPollEmbed],
                ['Suggestion', createSuggestionEmbed],
                ['Theme', createGiveawayEmbed]
            ]);
            for (let i = 0; i < collection.length; i++) {
                try {
                    embeds.push(createDecidableEmbed.get(decidablesType)(collection[i])
                        .setColor(pGuildClient.embedColor)
                        .setFooter(`Now viewing: ${i + 1}/${collection.length}`));
                }
                catch (err) {
                    PinguLibrary_1.errorLog(client, `Error while adding ${decidablesType.toLowerCase()} to embeds`, message.content, err);
                    toRemove.push(collection[i]);
                }
            }
            RemoveDecidables(message, pGuild, decidablesType, toRemove);
            if (!embeds && !autoCalled)
                return null;
            return embeds;
        }
    });
}
function Decide(params, approved, suggestion, decidedBy) {
    return __awaiter(this, void 0, void 0, function* () {
        suggestion = items_1.Suggestion.Decide(suggestion, approved, new PGuildMember_1.default(decidedBy));
        (function UpdateSuggestionEmbed() {
            return __awaiter(this, void 0, void 0, function* () {
                const channel = decidedBy.guild.channels.cache.get(suggestion.channel._id);
                const message = yield channel.messages.fetch(suggestion._id);
                return message.embeds[0].setFooter(`Suggestion was ${approved} by ${decidedBy}`);
            });
        })();
        return SaveVerdictToPGuilds(params, suggestion);
    });
}
function SaveVerdictToPGuilds(params, decidable) {
    return __awaiter(this, void 0, void 0, function* () {
        let { pGuild, client, decidablesType, config, message } = params;
        const { collection } = Configs.get(config);
        const itemIndex = collection.findIndex(d => d._id == decidable._id);
        collection[itemIndex] = decidable;
        UpdatePGuild(client, pGuild, decidablesType, `Saved verdict for "${decidable.value}" to ${message.guild.name}'s PinguGuild.`);
        return collection;
    });
}
function RemoveDecidables(message, pGuild, type, decidables) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!decidables || !decidables.length || !decidables[0])
            return;
        const { client, guild } = message;
        const decidablesConfig = pGuild.settings.config.decidables;
        const decidableConfig = decidablesConfig[`${type.toLowerCase()}Config`];
        const logs = new Array();
        for (const d of decidables) {
            const { collection } = Configs.get(decidableConfig);
            collection.splice(collection.indexOf(d), 1);
            logs.push(`The ${type}, ${d.value} (${d._id}) was removed.`);
        }
        if (logs.length)
            PinguLibrary_1.consoleLog(client, logs.join('\n'));
        yield UpdatePGuild(client, pGuild, type, `Removed ${logs.length} ${type.toLowerCase()}s from **${guild.name}**'s ${type} list.`);
        return Configs.get(decidableConfig).collection;
    });
}
function Reroll(params, sent, embed, decidable) {
    return __awaiter(this, void 0, void 0, function* () {
        const { message, args, decidablesType, client } = params;
        const { guild, channel, author } = message;
        const { edit } = sent;
        if (!args[1])
            return edit(`${decidablesType.toLowerCase()} message not found - please provide a message ID.`);
        let previousMessage = channel.messages.cache.get(args[1]);
        if (previousMessage) {
            previousMessage = channel.messages.cache.get(args[1].split('/')[6]);
            if (previousMessage)
                return edit(`Unable to parse ${args[1]} as ID, or message can't be found!`);
            else if (!previousMessage.embeds[0])
                return edit(`There's no embed in that message!`);
            else if (previousMessage.author.id != client.id)
                return edit(`That isn't my message!`);
        }
        const previousWinners = new Array();
        for (const winner of decidable.winners) {
            previousWinners.push(yield guild.members.fetch(winner._id));
        }
        return onTimeFinished(previousMessage, decidable.value, decidable.winners.length || 1, embed, decidable, null, params, previousWinners);
    });
}
function AddDecidableToPGuilds(params, decidable) {
    return __awaiter(this, void 0, void 0, function* () {
        const { client, message, pGuild, decidablesType, config } = params;
        Configs.get(config).collection.push(decidable);
        return UpdatePGuild(client, pGuild, decidablesType, `New ${decidablesType.toLowerCase()} was added to **${message.guild.name}**`);
    });
}
function UpdatePGuild(client, pGuild, decidableType, reason) {
    return __awaiter(this, void 0, void 0, function* () {
        return PinguGuild_1.default.Update(client, ['settings'], pGuild, `HandleDecidables: ${decidableType}`, reason);
    });
}
function isGiveawayType(decidablesType) {
    return ['Giveaway', 'Theme'].includes(decidablesType);
}
exports.default = HandleDecidables;
