"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecidablesTypes = exports.HandleDecidables = void 0;
const discord_js_1 = require("discord.js"); //Discord classes
const index_1 = require("../database/index"); //PItems
const helpers_1 = require("../helpers"); //Pingu Helpers
const PinguLibrary_1 = require("../pingu/library/PinguLibrary");
const PinguGuild_1 = require("../pingu/guild/PinguGuild");
const config_1 = require("../decidable/config"); //Decidable configs
const items_1 = require("../decidable/items"); //Decidable items
const ms = require('ms');
var DecidablesTypes;
(function (DecidablesTypes) {
    DecidablesTypes["Giveaway"] = "Giveaway";
    DecidablesTypes["Poll"] = "Poll";
    DecidablesTypes["Suggestion"] = "Suggestion";
})(DecidablesTypes || (DecidablesTypes = {}));
exports.DecidablesTypes = DecidablesTypes;
function HandleDecidables(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { message, args, pGuild, pGuildClient, decidablesType, listEmojis, config, reactionEmojis } = params;
        const { firstTimeExecuted, channel } = config;
        const reroll = () => Is(DecidablesTypes.Giveaway) && args[0] == `reroll`;
        if (!pGuild) {
            yield PinguLibrary_1.PinguLibrary.errorLog(message.client, `Unable to host ${decidablesType.toLowerCase()} for ${message.guild.name}, as I couldn't get their PinguGuild!`);
            return message.channel.send(`I couldn't get your PinguGuild, so I can't host the ${decidablesType.toLowerCase()} for you!`);
        }
        //Test if all permissions are available & if all arguments are met
        let permCheck = yield PermissionCheck(params);
        if (permCheck != PinguLibrary_1.PinguLibrary.PermissionGranted)
            return message.channel.send(permCheck);
        //Is user trying to host?
        if (firstTimeExecuted || args[0] == 'setup')
            return yield FirstTimeExecuted(params);
        else if (args[0] == 'list')
            return ListDecidables(params, Is(DecidablesTypes.Giveaway) ? pGuild.giveawayConfig.giveaways :
                Is(DecidablesTypes.Poll) ? pGuild.pollConfig.polls :
                    pGuild.suggestionConfig.suggestions);
        //#region Variable Creation
        if (!Is(DecidablesTypes.Suggestion)) {
            var time = args[0];
            if (reroll())
                args.shift();
            else if (Is(DecidablesTypes.Giveaway)) {
                var winners = 1;
                if (args[0].endsWith('w') && !isNaN(parseInt(args[0].substr(0, args[0].length - 1)))) {
                    let winnerString = args.shift();
                    winners = parseInt(winnerString.substring(0, winnerString.length - 1));
                }
            }
        }
        var decidablesChannel = message.guild.channels.cache.find(c => [c.id, c.name].includes(args[0]) || c == message.mentions.channels.first());
        if (decidablesChannel)
            args.shift();
        else
            decidablesChannel = (args[0] != `reroll` ? message.guild.channels.cache.find(c => c.id == channel._id) || message.channel : message.channel);
        let check = {
            author: message.author,
            channel: decidablesChannel,
            client: message.client,
            content: message.content
        };
        let channelPerms = PinguLibrary_1.PinguLibrary.PermissionCheck(check, [helpers_1.DiscordPermissions.VIEW_CHANNEL]);
        if (channelPerms != PinguLibrary_1.PinguLibrary.PermissionGranted)
            return message.channel.send(channelPerms);
        check.author = message.client.user;
        channelPerms = PinguLibrary_1.PinguLibrary.PermissionCheck(check, [helpers_1.DiscordPermissions.SEND_MESSAGES, helpers_1.DiscordPermissions.ADD_REACTIONS]);
        if (channelPerms != PinguLibrary_1.PinguLibrary.PermissionGranted)
            return message.channel.send(channelPerms);
        let value = args.join(' ');
        let mention = message.mentions.users.first();
        if (value.includes('<@'))
            value = value.replace(/(<@!*[\d]{18}>)/, (message.guild.member(mention) ? message.guild.member(mention).displayName : mention.username));
        if (!Is(DecidablesTypes.Suggestion))
            var endsAt = new Date(Date.now() + ms(time));
        let embed = new discord_js_1.MessageEmbed()
            .setTitle(Is(DecidablesTypes.Suggestion) ? 'Suggestion' : value)
            .setColor(pGuildClient.embedColor)
            .setDescription((Is(DecidablesTypes.Giveaway) ? (`React with :fingers_crossed: to enter!\n` +
            `Winners: **${winners}**\n` +
            `Ends in: ${new helpers_1.TimeLeftObject(new Date(Date.now()), endsAt).toString()}\n` +
            `Hosted by ${message.author}`) :
            Is(DecidablesTypes.Poll) ?
                `Brought to you by <@${message.author.id}>\n` +
                    `Time left: ${new helpers_1.TimeLeftObject(new Date(Date.now()), endsAt).toString()}` :
                value))
            .setFooter(Is(DecidablesTypes.Suggestion) ? `This suggestion is currently Undecided` : `Ends at`)
            .setTimestamp(Is(DecidablesTypes.Suggestion) ? null : endsAt);
        //#endregion
        if (reroll())
            yield message.channel.send(`Rerolling giveaway...`);
        else if (message.channel.id == decidablesChannel.id &&
            PinguLibrary_1.PinguLibrary.PermissionCheck({ author: message.client.user, client: message.client, channel: decidablesChannel, content: null }, [helpers_1.DiscordPermissions.MANAGE_MESSAGES]) == PinguLibrary_1.PinguLibrary.PermissionGranted)
            message.delete();
        else
            message.channel.send(`Announcing the ${decidablesType.toLowerCase()} in ${decidablesChannel} now!`).then(sent => sent.delete({ timeout: 5000 }));
        //Giveaway reroll
        if (reroll())
            return yield Reroll(params, embed, pGuild.giveawayConfig.giveaways.find(g => g._id == value));
        //Announce decidable
        let sent = yield message.channel.send(`New ${decidablesType}!`, embed);
        reactionEmojis.forEach((emoji) => __awaiter(this, void 0, void 0, function* () { return yield sent.react(emoji); }));
        PinguLibrary_1.PinguLibrary.consoleLog(message.client, `${message.author} hosted ${decidablesType} in #${decidablesChannel.name}, ${message.guild}`);
        let decidable = new items_1.Decidable(value, sent.id, new index_1.PGuildMember(message.member), decidablesChannel, endsAt);
        AddDecidableToPGuilds(params, decidable);
        if (Is(DecidablesTypes.Suggestion))
            return;
        var interval = setInterval(() => UpdateTimer(), ms('5s'));
        setTimeout(() => AfterTimeOut(sent, value, winners, embed, decidable, interval, params, null), ms(time));
        function UpdateTimer() {
            sent.edit(sent.embeds[0].setDescription(Is(DecidablesTypes.Giveaway) ? (`React with :fingers_crossed: to enter!\n` +
                `Winners: **${winners}**\n` +
                `Ends in: ${new helpers_1.TimeLeftObject(new Date(Date.now()), endsAt).toString()}\n` +
                `Hosted by <@${decidable.author._id}>`) : Is(DecidablesTypes.Poll) ? (`Brought to you by <@${decidable.author._id}>\n` +
                `Time left: ${new helpers_1.TimeLeftObject(new Date(Date.now()), endsAt).toString()}`) : sent.embeds[0].description)).catch((err) => __awaiter(this, void 0, void 0, function* () {
                yield PinguLibrary_1.PinguLibrary.errorLog(message.client, `Updating ${decidablesType.toLowerCase()} timer`, message.content, err);
                message.author.send(`I had an issue updating the ${decidablesType.toLowerCase()} message, so your ${decidablesType.toLowerCase()} might be broken!`);
            }));
        }
        function Is(type) {
            return decidablesType == type;
        }
    });
}
exports.HandleDecidables = HandleDecidables;
function PermissionCheck(params) {
    return __awaiter(this, void 0, void 0, function* () {
        let { message, config, args, decidablesType, pGuild } = params;
        let pRole = DecidablesTypes.Giveaway == decidablesType ? config.hostRole :
            DecidablesTypes.Poll == decidablesType ? config.pollRole :
                config.managerRole;
        if (config.firstTimeExecuted || ["reroll", "setup", "list"].includes(args[0]))
            return PinguLibrary_1.PinguLibrary.PermissionGranted;
        else if (!args[0] && !args[1])
            return `You didn't give me enough arguments!`;
        yield CheckRoleUpdates();
        if (decidablesType == DecidablesTypes.Suggestion)
            return PinguLibrary_1.PinguLibrary.PermissionGranted;
        if (!message.member.hasPermission(helpers_1.DiscordPermissions.ADMINISTRATOR) && pRole && !message.member.roles.cache.has(pRole._id))
            return "You don't have `Administrator` permissions" + (pRole ? ` or the \`${pRole.name}\` role` : "" + "!");
        if (decidablesType == DecidablesTypes.Giveaway && args[0].endsWith('w') && !isNaN(parseInt(args[0].substring(0, args[0].length - 1))))
            args.shift();
        else if (args[0].endsWith('s') && parseInt(args[0].substring(0, args[0].length - 1)) < 30)
            return 'Please specfify a time higher than 29s';
        else if (!ms(args[0]))
            return 'Please provide a valid time!';
        else if (!isNaN(parseInt(args[0].substring(args[0].length - 1, args[0].length)))) //No s,m,h provided, treat as minutes
            args[0] = args[0] + "m";
        return PinguLibrary_1.PinguLibrary.PermissionGranted;
        function CheckRoleUpdates() {
            return __awaiter(this, void 0, void 0, function* () {
                let staffPRole = pRole;
                let winnerPRole = decidablesType == DecidablesTypes.Giveaway ? pGuild.giveawayConfig.winnerRole : undefined;
                let winnerRole = CheckRole(winnerPRole);
                let staffRole = CheckRole(staffPRole);
                if (!winnerRole && winnerPRole != undefined || winnerPRole != undefined && winnerRole || //Winner role (doesn't) exist(s)
                    !staffRole && staffPRole != undefined || staffPRole != undefined && staffRole || //Staff role (doesn't) exist(s)
                    winnerPRole && winnerRole && winnerRole.name != winnerPRole.name || //Winner role's name changed
                    staffPRole && staffPRole && staffRole.name != staffPRole.name) //Staff role's name changed
                    yield UpdatePGuild(message.client, pGuild, decidablesType, `Updated ${decidablesType.toLowerCase()} role${decidablesType == DecidablesTypes.Giveaway ? 's' : ''}`, `I encountered and error while updating ${decidablesType.toLowerCase()} role${decidablesType == DecidablesTypes.Giveaway ? 's' : ''}`);
                function CheckRole(pRole) {
                    if (!pRole)
                        return undefined;
                    return message.guild.roles.cache.find(r => r.id == pRole._id);
                }
            });
        }
    });
}
function FirstTimeExecuted(params) {
    return __awaiter(this, void 0, void 0, function* () {
        let { args, message, decidablesType, pGuild } = params;
        if (args[0] != 'setup')
            message.channel.send(`**Hold on fella!**\nWe need to get ${message.guild.name} set up first!`);
        let collector = message.channel.createMessageCollector(m => m.author.id == message.author.id, { max: 1 }), collectorCount = 0, reply = "";
        if (yield HasAllArguments())
            return;
        let staffRoleType = decidablesType == DecidablesTypes.Giveaway ? 'Giveaway Host' : decidablesType == DecidablesTypes.Poll ? 'Poll Host' : 'Suggestion Manager';
        let decidablesChannelName = decidablesType.toLowerCase();
        let hostDone = false;
        message.channel.send(`Firstly, ${Find('Role', staffRoleType, 'Exists', null)}`);
        collector.on('collect', (input) => __awaiter(this, void 0, void 0, function* () {
            let userInput = input;
            let lastInput = userInput.content.toLowerCase();
            switch (collectorCount) {
                case 0:
                    reply = Find('Role', hostDone ? 'Giveaway Winner' : staffRoleType, 'Create', userInput);
                    break;
                case 1:
                    if (!hostDone) {
                        var staffRoleResult = Find('Role', hostDone ? 'Giveaway Winner' : staffRoleType, 'Find', userInput);
                        var staffRole = !["undefined", "Make"].includes(staffRoleResult) ? message.guild.roles.cache.get(staffRoleResult) : staffRoleResult;
                        reply = null;
                        if (decidablesType == DecidablesTypes.Giveaway) {
                            reply = Find('Role', 'Giveaway Winner', 'Exists', userInput);
                            collectorCount = -1;
                        }
                    }
                    else {
                        var winnerRoleResult = Find('Role', "Giveaway Winner", 'Find', userInput);
                        var winnerRole = !["undefined", "Make"].includes(winnerRoleResult) ? message.guild.roles.cache.get(winnerRoleResult) : winnerRoleResult;
                    }
                    hostDone = true;
                    if (!reply)
                        reply = Find('Channel', decidablesChannelName, 'Exists', userInput);
                    break;
                case 2:
                    reply = Find('Role', hostDone ? 'Giveaway Winner' : staffRoleType, 'Create', userInput);
                    break;
                case 3:
                    var decidablesChannelResult = Find('Channel', decidablesChannelName, 'Find', userInput);
                    var decidablesChannel = !["undefined", "Make"].includes(decidablesChannelResult) ? message.guild.channels.cache.get(decidablesChannelResult) : decidablesChannelResult;
                    //Giveaway allowSameWinner
                    if (decidablesType != DecidablesTypes.Giveaway)
                        return GoodToGo({ staffRole, decidablesChannel });
                    reply = `Alright last thing, should I allow same winners? (A user wins a giveaway can't win the next one, if you say no)`;
                    break;
                case 4: return GoodToGo({ staffRole, decidablesChannel, winnerRole, allowSameWinner: lastInput == 'yes' });
                default:
                    PinguLibrary_1.PinguLibrary.errorLog(message.client, `Ran default in HandleDecidables, ${decidablesType}, collector.on, FirstTimeExecuted(), ${collectorCount}`, message.content);
                    collector.stop("Ran default switch-case");
                    return;
            }
            collectorCount++;
            if (!reply) {
                switch (collectorCount) {
                    case 0:
                        reply = `I need to know if there's a ${hostDone ? 'Giveaway Winner' : staffRoleType} role! \`Yes\` or \`no\`?`;
                        break;
                    case 1:
                        reply = lastInput == `yes` ?
                            "Please tag the role, or send the role ID." :
                            `I need to know if you would like a **${hostDone ? 'Giveaway Winner' : staffRoleType}** role.`;
                        break;
                    case 3: reply = lastInput == 'yes' ?
                        "Please tag the channel, or send the channel ID" :
                        `I need to know if you would like a channel for ${decidablesChannelName}.`;
                    default: return PinguLibrary_1.PinguLibrary.errorLog(message.client, `Ran default in HandleDecidables, ${decidablesType}, collector.on, FirstTimeExecuted(), ${collectorCount}, !reply`, message.content);
                }
                collectorCount--;
            }
            message.channel.send(reply);
        }));
        collector.on('end', () => __awaiter(this, void 0, void 0, function* () {
            message.channel.send(`Alright, you're all set!`);
            PinguLibrary_1.PinguLibrary.consoleLog(message.client, `"${message.guild.name}" was successfully sat up with *${decidablesType.toLowerCase()}.`);
            if (args[0] != 'setup')
                return HandleDecidables(params);
        }));
        function HasAllArguments() {
            return __awaiter(this, void 0, void 0, function* () {
                /*
                 [0]: setup
                 [1]: staffRole
                 [2]: channel || winnerRole
                 [3]: null || channel
                 [4]: null || sameWinner
                 */
                if (decidablesType == DecidablesTypes.Giveaway && args.length != 5)
                    return false; //Not enough arguments
                else if (args.length != 3 || !isNaN(ms(args[0])))
                    return false; //Not enough arguments & args[0] is not ms convertable (is a number, but not 'ms' number(?))
                class T {
                }
                let find = (i, arg) => { return [i.id, i.name.toLowerCase(), i.toString().toLowerCase()].includes(arg) && i; };
                let findRole = (argument) => argument == 'null' ? null : message.guild.roles.cache.find(r => find(r, argument) != null);
                let findChannel = (argument) => argument == 'null' ? null : message.guild.channels.cache.find(c => find(c, argument) && c.isText());
                var staffRole = findRole(args[1]);
                let channel = findChannel(args[decidablesType != DecidablesTypes.Giveaway ? 2 : 3]);
                if (decidablesType == DecidablesTypes.Giveaway)
                    yield GoodToGo({ staffRole, decidablesChannel: channel, winnerRole: findRole(args[2]), allowSameWinner: ['yes', 'true'].includes(args[4].toLowerCase()) });
                else
                    yield GoodToGo({ staffRole, decidablesChannel: channel });
                message.channel.send('Setup done!');
                return true;
            });
        }
        /**
         * @returns Response to 'Exists' & 'Create', but returns id of type || "Make" || "undefined" as final result
         */
        function Find(type, typeName, pinguResponse, userInput) {
            let response = userInput.content.toLowerCase();
            let typeResult = null;
            switch (pinguResponse) {
                case 'Exists': return `Do you have a ${typeName} ${type.toLowerCase()}?`;
                case 'Create': return response == 'yes' ? `Please tag the ${type.toLowerCase()} or send the ${type.toLowerCase()} ID` : response == 'no' ? `Would you like a **${typeName}** ${type.toLowerCase()}?` : null;
                case 'Find':
                    typeResult = type == 'Role' ?
                        (message.guild.roles.cache.find(r => [r.id, r.name.toLowerCase()].includes(response)) || userInput.mentions.roles.first()) :
                        (message.guild.channels.cache.find(c => [c.id, c.name.toLowerCase()].includes(response)) || userInput.mentions.channels.first());
                    if (typeResult)
                        message.channel.send(`Okay, I found ${typeResult.name}`);
                    else if (response == 'yes') {
                        typeResult = 'Make';
                        message.channel.send(`Okay, I'll make that...`);
                    }
                    else if (response == 'no') {
                        typeResult = 'undefined';
                        message.channel.send(`Okay, I won't make that...`);
                    }
                    return typeResult.id;
            }
        }
        function GoodToGo(params) {
            return __awaiter(this, void 0, void 0, function* () {
                let { decidablesChannel, staffRole, allowSameWinner, winnerRole } = params;
                if (typeof staffRole == 'string' && staffRole == 'Make')
                    staffRole = yield MakeRole(message.guild, staffRoleType);
                if (typeof decidablesChannel == 'string' && decidablesChannel == 'Make')
                    decidablesChannel = yield MakeChannel(message.guild, decidablesChannelName);
                if (winnerRole && typeof winnerRole == 'string' && winnerRole == 'Make')
                    winnerRole = yield MakeRole(message.guild, "Giveaway Winner");
                switch (decidablesType) {
                    case DecidablesTypes.Giveaway:
                        pGuild.giveawayConfig = new config_1.GiveawayConfig({
                            firstTimeExecuted: false,
                            allowSameWinner,
                            channel: new index_1.PChannel(decidablesChannel),
                            hostRole: new index_1.PRole(staffRole),
                            winnerRole: new index_1.PRole(winnerRole),
                            giveaways: []
                        });
                        break;
                    case DecidablesTypes.Poll:
                        pGuild.pollConfig = new config_1.PollConfig({
                            firstTimeExecuted: false,
                            channel: new index_1.PChannel(decidablesChannel),
                            pollRole: new index_1.PRole(staffRole),
                            polls: []
                        });
                        break;
                    case DecidablesTypes.Suggestion:
                        pGuild.suggestionConfig = new config_1.SuggestionConfig({
                            firstTimeExecuted: false,
                            channel: new index_1.PChannel(decidablesChannel),
                            managerRole: new index_1.PRole(staffRole),
                            suggestions: []
                        });
                        break;
                }
                yield UpdatePGuild(message.client, pGuild, decidablesType, `Successfully saved **${pGuild.name}**'s ${decidablesType} config`, `Failed to save **${pGuild.name}**'s ${decidablesType} config`);
                return decidablesType == DecidablesTypes.Giveaway ? pGuild.giveawayConfig :
                    decidablesType == DecidablesTypes.Poll ? pGuild.pollConfig : pGuild.suggestionConfig;
                function MakeRole(guild, name) {
                    return __awaiter(this, void 0, void 0, function* () {
                        return guild.roles.create({
                            data: { name },
                            reason: `Auto-created when setting up ${decidablesType.toLowerCase()}`
                        }).catch(err => {
                            PinguLibrary_1.PinguLibrary.errorLog(message.client, `Creating ${name} role`, message.content, err);
                            return null;
                        });
                    });
                }
                function MakeChannel(guild, name) {
                    return __awaiter(this, void 0, void 0, function* () {
                        return guild.channels.create(name, {
                            reason: `Auto-created when setting up ${decidablesType.toLowerCase()}`
                        }).catch(err => {
                            PinguLibrary_1.PinguLibrary.errorLog(message.client, `Creating ${name} channel`, message.content, err);
                            return null;
                        });
                    });
                }
            });
        }
    });
}
function ListDecidables(params, decidables) {
    return __awaiter(this, void 0, void 0, function* () {
        let { pGuild, listEmojis, decidablesType, message, pGuildClient } = params;
        let embeds = CreateEmbeds(false), embedIndex = 0;
        if (!decidables.length || !embeds.length)
            return message.channel.send(`There are no ${decidablesType.toLowerCase()} saved!`);
        var sent = yield message.channel.send(embeds[embedIndex]);
        listEmojis.forEach(e => sent.react(e));
        if (decidablesType == DecidablesTypes.Suggestion)
            listEmojis[1] = 'Checkmark';
        const reactionCollector = sent.createReactionCollector((reaction, user) => listEmojis.includes(reaction.emoji.name) && user.id == message.author.id, { time: ms('20s') });
        reactionCollector.on('end', (reactionsCollected) => __awaiter(this, void 0, void 0, function* () {
            if (!reactionsCollected.array().map(r => r.emoji.name).includes('üõë')) {
                yield sent.delete();
                message.channel.send(`Stopped showing ${decidablesType.toLowerCase()}.`).then(sent => sent.delete({ timeout: 5000 }));
            }
        }));
        reactionCollector.on('collect', (reaction) => __awaiter(this, void 0, void 0, function* () {
            let decidable = decidables.find(d => d._id == (decidablesType == DecidablesTypes.Giveaway ?
                reaction.message.embeds[0].fields[0].value :
                reaction.message.embeds[0].description.substring(4, reaction.message.embeds[0].description.length)));
            reactionCollector.resetTimer({ time: ms('20s') });
            switch (reaction.emoji.name) {
                case '‚¨ÖÔ∏è':
                    var embedToSend = yield ReturnEmbed(-1);
                    break;
                case 'Checkmark':
                case '‚ùå':
                    if (decidablesType != DecidablesTypes.Suggestion) {
                        embedToSend = sent.embeds[0];
                        break;
                    }
                    decidables = yield Decide(params, reaction.emoji.name != '‚ùå', decidable, message.member);
                    CreateEmbeds(true);
                    embedToSend = yield ReturnEmbed(1);
                    break;
                case 'üóëÔ∏è':
                    embedToSend = yield ReturnEmbed(0);
                    break;
                case '‚û°Ô∏è':
                    embedToSend = yield ReturnEmbed(1);
                    break;
                case 'üõë':
                    reactionCollector.stop();
                    return;
                default:
                    PinguLibrary_1.PinguLibrary.errorLog(message.client, `${decidablesType.toLowerCase()}, ListDecidables(), reactionCollector.on() default case: ${reaction.emoji.name}`, message.content);
                    embedToSend = reaction.message.embeds[0];
                    break;
            }
            if (!decidables.length || !embedToSend) {
                message.channel.send(`No more ${decidablesType.toLowerCase()}s to find!`);
                return reactionCollector.stop();
            }
            yield sent.edit(embedToSend.setFooter(`Now viewing: ${embedIndex + 1}/${embeds.length}`));
            sent.reactions.cache.forEach(r => {
                if (r.users.cache.size > 1)
                    r.users.cache.forEach((user) => __awaiter(this, void 0, void 0, function* () {
                        if (user.id != message.client.user.id)
                            yield r.users.remove(user);
                    }));
            });
            function ReturnEmbed(index) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!embeds)
                        return null;
                    embedIndex += index;
                    if (embedIndex <= 1) {
                        embedIndex = embeds.length - 1;
                        index = -1;
                    }
                    else if (embedIndex >= embeds.length) {
                        embedIndex = 0;
                        index = 1;
                    }
                    if (index == 0)
                        return yield DeleteDecidable(embeds[embedIndex]);
                    return embeds[embedIndex];
                });
            }
            function DeleteDecidable(embed) {
                return __awaiter(this, void 0, void 0, function* () {
                    const deletingDecidable = decidables.find(d => d._id == (decidablesType == DecidablesTypes.Suggestion ?
                        reaction.message.embeds[0].description.substring(4, reaction.message.embeds[0].description.length) :
                        reaction.message.embeds[0].fields[0].value));
                    decidables = yield RemoveDecidables(message, pGuild, decidablesType, [deletingDecidable]);
                    embeds = CreateEmbeds(true);
                    return !decidables.includes(decidable) ?
                        yield DoTheEmojiThing('‚úÖ', 1) :
                        yield DoTheEmojiThing('‚ùå', -1);
                    function DoTheEmojiThing(emote, index) {
                        return __awaiter(this, void 0, void 0, function* () {
                            yield sent.react(emote);
                            yield setTimeout(() => __awaiter(this, void 0, void 0, function* () { return yield sent.reactions.cache.find(r => r.emoji.name == emote).remove(); }), 1500);
                            return yield ReturnEmbed(index);
                        });
                    }
                });
            }
        }));
        function CreateEmbeds(autocalled) {
            let embeds = new Array(), ToRemove = new Array();
            if (!decidables.length)
                return null;
            for (var i = 0; i < decidables.length; i++) {
                try {
                    embeds[i] = (decidablesType == DecidablesTypes.Giveaway ? CreateGiveawayEmbed(decidables[i]) :
                        decidablesType == DecidablesTypes.Poll ? CreatePollEmbed(decidables[i]) : CreateSuggestionEmbed(decidables[i]))
                        .setColor(pGuildClient.embedColor)
                        .setFooter(`Now viewing: ${i + 1}/${decidables.length}`);
                }
                catch (err) {
                    PinguLibrary_1.PinguLibrary.errorLog(message.client, `Error while adding ${decidablesType.toLowerCase()} to embeds`, message.content, err);
                    ToRemove.push(decidables[i]);
                }
            }
            RemoveDecidables(message, pGuild, decidablesType, ToRemove);
            if (!embeds && !autocalled)
                return null;
            return embeds;
            function CreateGiveawayEmbed(g) {
                const winners = g.winners.map(pg => `<@${pg._id}>`).join(", ") || "No winners", host = `<@${g.author._id}>`;
                return new discord_js_1.MessageEmbed()
                    .setTitle(g.value)
                    .setDescription(`**__Winner(s)__**\n` + winners)
                    .addField(`ID`, g._id, true)
                    .addField(`Host`, host, true);
            }
            function CreatePollEmbed(p) {
                return new discord_js_1.MessageEmbed()
                    .setTitle(p.value)
                    .setDescription(`ID: ${p._id}`)
                    .addField(`Verdict`, p.approved, true)
                    .addField(`Host`, `<@${p.author._id}>`, true);
            }
            function CreateSuggestionEmbed(s) {
                return new discord_js_1.MessageEmbed()
                    .setTitle(s.value)
                    .setDescription(`ID: ${s._id}`)
                    .addFields([
                    new helpers_1.EmbedField(`Verdict`, `${(s.approved == 'Approved' ? GetCheckMark(message.client) : s.approved == 'Denied' ? '‚ùå' : 'ü§∑')}` + s.approved, true),
                    new helpers_1.EmbedField(`Suggested By`, `<@${s.author._id}>`, true),
                    s.approved != 'Undecided' ? new helpers_1.EmbedField(`Decided By`, `<@${s.decidedBy._id}>`, true) : PinguLibrary_1.PinguLibrary.BlankEmbedField(true)
                ]);
            }
        }
    });
}
function AfterTimeOut(sent, value, amountOfWinners, embed, decidable, interval, params, previousWinner) {
    return __awaiter(this, void 0, void 0, function* () {
        clearInterval(interval);
        let { decidablesType, pGuild, message } = params;
        if (decidablesType == DecidablesTypes.Poll)
            DecidePoll(decidable);
        else
            GetGiveawayWinner(decidable);
        SaveVerdictToPGuilds(params, decidable);
        PinguLibrary_1.PinguLibrary.consoleLog(sent.client, `Updated ${decidablesType.toLowerCase()} "${decidable._id}" after timeout.`);
        function DecidePoll(poll) {
            poll = items_1.Poll.Decide(poll, sent.reactions.cache.get('üëç').count, sent.reactions.cache.get('üëé').count);
            //Submitting Verdict
            sent.channel.send(`The poll of "**${poll.value}**", voted **${poll.approved}**!`);
            sent.edit(embed
                .setTitle(`FINISHED!: ${poll.value}`)
                .setDescription(`Voting done! Final answer: ${poll.approved}`)
                .setFooter(`Poll Ended.`));
        }
        function GetGiveawayWinner(giveaway) {
            return __awaiter(this, void 0, void 0, function* () {
                const giveawayCreator = sent.guild.member(decidable.author._id);
                const pGuildGiveaway = pGuild.giveawayConfig, GiveawayWinnerRole = pGuildGiveaway.winnerRole, allowSameWinner = pGuildGiveaway.allowSameWinner;
                let winners = new Array();
                try {
                    var peopleReacted = (yield sent.reactions.cache.get('ü§û').users.fetch()).array();
                }
                catch (err) {
                    yield PinguLibrary_1.PinguLibrary.errorLog(sent.client, `Fetching ü§û reactions from giveaway`, sent.content, err);
                    var GiveawayCreatorDM = yield giveawayCreator.createDM();
                    GiveawayCreatorDM.send(`Hi! I ran into an issue while finding a winner for your giveaway "${value}"... I've already contacted my developers!`);
                }
                let members = yield sent.guild.members.fetch({ user: peopleReacted });
                peopleReacted = peopleReacted.filter(user => !user.bot && //Not bot
                    allowSameWinner != null && ( //allowSameWinner exists
                allowSameWinner || //Allow same winner
                    GiveawayWinnerRole && //Giveaway role exists
                        !members.get(user.id).roles.cache.has(GiveawayWinnerRole._id) //Don't allow same winner and user doesn't have giveaway winner role
                ));
                // While there's no winner
                for (var i = 0; i < amountOfWinners; i++) {
                    var winner = FindWinner();
                    while (!winner || previousWinner && previousWinner.id == winner.id)
                        winner = FindWinner();
                    //Winner not found
                    if (typeof winner == 'string' && winner == `A winner couldn't be found!`)
                        winner = "no one";
                    winners[i] = sent.guild.member(winner);
                    peopleReacted.splice(peopleReacted.indexOf(winner), 1);
                }
                if (winner == `no one` || !winners.length || !winners[0]) {
                    sent.edit(embed
                        .setTitle(`Unable to find a winner for "${value}"!`)
                        .setDescription(`Winner not found!`)
                        .setFooter(`Giveaway ended.`));
                    return sent.channel.send(`A winner to "**${value}**" couldn't be found!`);
                }
                let WinnerArrStringed = winners.join(' & ');
                //Announce Winner
                var WinnerMessage = yield sent.channel.send(`The winner of "**${value}**" is no other than ${WinnerArrStringed}! Congratulations!`);
                WinnerMessage.react(PinguLibrary_1.PinguLibrary.getEmote(sent.client, 'hypers', PinguLibrary_1.PinguLibrary.SavedServers.PinguSupport(sent.client)));
                RemovePreviousWinners(sent.guild.members.cache.filter(Member => Member.roles.cache.has(GiveawayWinnerRole._id)).array());
                let gCreatorMessage = '';
                for (var i = 0; i < winners.length; i++) {
                    yield sent.guild.member(winners[i]).roles.add(GiveawayWinnerRole._id)
                        .catch((err) => __awaiter(this, void 0, void 0, function* () {
                        if (err != `TypeError [INVALID_TYPE]: Supplied roles is not a Role, Snowflake or Array or Collection of Roles or Snowflakes.`) {
                            yield PinguLibrary_1.PinguLibrary.errorLog(sent.client, `Unable to give <@${winner.id}> "${sent.guild.name}"'s Giveaway Winner Role, ${GiveawayWinnerRole.name} (${GiveawayWinnerRole._id})`, message.content, err);
                            giveawayCreator.user.send(`I couldn't give <@${winner.id}> a Giveaway Winner role! I have already notified my developers.`);
                        }
                        //`Please give me a role above the Giveaway Winner role, or move my role above it!`
                    }));
                    gCreatorMessage += `<@${winners[i].id}> & `;
                }
                giveawayCreator.user.send(gCreatorMessage.substring(0, gCreatorMessage.length - 3) + ` won your giveaway, "**${value}**" in **${sent.guild.name}**!\n${sent.url}`);
                //Edit embed to winner
                sent.edit(embed
                    .setTitle(`Winner of "${value}"!`)
                    .setDescription(`${(winners.length == 1 ? `Winner` : `Winners`)}: ${WinnerArrStringed}\nHosted by: ${giveawayCreator.user}`)
                    .setFooter('Giveaway ended.')).catch(err => PinguLibrary_1.PinguLibrary.errorLog(sent.client, `Editing the Giveaway Message`, sent.content, err)
                    .then(() => giveawayCreator.user.send(`I had an error while updating the original giveaway message... I've already notified my developers!`)));
                yield UpdatePGuildWinners();
                function FindWinner() {
                    let winner = SelectWinner();
                    if (typeof winner == 'string')
                        return winner;
                    // If PreviousWinner roles don't exist
                    if (!GiveawayWinnerRole)
                        message.author.send(`I couldn't find a "Giveaway Winner(s)" role!\nI have selected a random winner from everyone.`);
                    return winners.includes(sent.guild.member(winner)) ? null : winner;
                    function SelectWinner() {
                        if (!peopleReacted.length)
                            return `A winner couldn't be found!`;
                        let winner = peopleReacted[Math.floor(Math.random() * peopleReacted.length)];
                        if (!GiveawayWinnerRole)
                            return winner;
                        else if (message.guild.member(winner).roles.cache.has(GiveawayWinnerRole._id))
                            return pGuildGiveaway.allowSameWinner ? winner : null;
                        return winner;
                    }
                }
                function RemovePreviousWinners(WinnerArray) {
                    for (var x = 0; x < WinnerArray.length; x++)
                        WinnerArray[x].roles.remove(GiveawayWinnerRole._id);
                }
                function UpdatePGuildWinners() {
                    return __awaiter(this, void 0, void 0, function* () {
                        for (var i = 0; i < winners.length; i++) {
                            giveaway.winners.push(new index_1.PGuildMember(sent.guild.member(winners[i])));
                        }
                    });
                }
            });
        }
    });
}
function RemoveDecidables(message, pGuild, type, decidables) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!decidables || !decidables.length || !decidables[0])
            return;
        decidables.forEach(d => type == DecidablesTypes.Giveaway ? pGuild.giveawayConfig.giveaways.splice(pGuild.giveawayConfig.giveaways.indexOf(d), 1) :
            type == DecidablesTypes.Poll ? pGuild.pollConfig.polls.splice(pGuild.pollConfig.polls.indexOf(d), 1) :
                pGuild.suggestionConfig.suggestions.splice(pGuild.suggestionConfig.suggestions.indexOf(d), 1));
        PinguLibrary_1.PinguLibrary.consoleLog(message.client, `The ${type}, ${decidables[0].value} (${decidables[0]._id}) was removed.`);
        yield UpdatePGuild(message.client, pGuild, type, `Removed ${decidables.length} ${type}s from **${message.guild.name}**'s ${type} list.`, `Removing ${decidables[0]._id} (${decidables[0].value}) from **${message.guild.name}**'s ${type} list`);
        switch (type) {
            case DecidablesTypes.Giveaway: return pGuild.giveawayConfig.giveaways;
            case DecidablesTypes.Poll: return pGuild.pollConfig.polls;
            case DecidablesTypes.Suggestion: return pGuild.suggestionConfig.suggestions;
        }
    });
}
function Reroll(params, embed, giveaway) {
    return __awaiter(this, void 0, void 0, function* () {
        let { message, args } = params;
        if (!args[1])
            return message.edit(`Giveaway message not found - please provide with a message ID`);
        let PreviousGiveawayMessage = message.channel.messages.cache.find(premsg => premsg.id == args[1]);
        if (!PreviousGiveawayMessage) {
            PreviousGiveawayMessage = message.channel.messages.cache.find(premsg => premsg.id == args[1].split('/')[6]);
            if (!PreviousGiveawayMessage)
                return message.author.send(`Unable to parse ${args[1]} as ID, or message can't be found!`);
            else if (!PreviousGiveawayMessage.embeds[0])
                return message.author.send(`I couldn't find the giveaway embed from that message link!`);
        }
        return yield AfterTimeOut(PreviousGiveawayMessage, giveaway.value, giveaway.winners.length || 1, embed, giveaway, null, params, message.guild.members.cache.get(giveaway.winners[0]._id));
    });
}
function Decide(params, approved, suggestion, decidedBy) {
    return __awaiter(this, void 0, void 0, function* () {
        suggestion = items_1.Suggestion.Decide(suggestion, approved, new index_1.PGuildMember(decidedBy));
        UpdateSuggestionEmbed(decidedBy.guild.channels.cache.get(suggestion.channel._id));
        return yield SaveVerdictToPGuilds(params, suggestion);
        function UpdateSuggestionEmbed(channel) {
            return __awaiter(this, void 0, void 0, function* () {
                let fetchedMessage = yield channel.messages.fetch(suggestion._id);
                return fetchedMessage.embeds[0].setFooter(`Suggestion was ${suggestion.value} by <@${suggestion.author._id}>`);
            });
        }
    });
}
function GetCheckMark(client) {
    return PinguLibrary_1.PinguLibrary.SavedServers.DanhoMisc(client).emojis.cache.find(e => e.name == 'Checkmark');
}
function UpdatePGuild(client, pGuild, decidableType, succMsg, errMsg) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield PinguGuild_1.PinguGuild.UpdatePGuild(client, decidableType == DecidablesTypes.Giveaway ? { giveawayConfig: pGuild.giveawayConfig } :
            decidableType == DecidablesTypes.Poll ? { pollConfig: pGuild.pollConfig } :
                { suggestionConfig: pGuild.suggestionConfig }, pGuild, `HandleDecidables: ${decidableType}`, succMsg, errMsg);
    });
}
function SaveVerdictToPGuilds(params, decidable) {
    return __awaiter(this, void 0, void 0, function* () {
        let { pGuild, message, decidablesType } = params;
        const arr = (decidablesType == DecidablesTypes.Giveaway ? pGuild.giveawayConfig.giveaways : decidablesType == DecidablesTypes.Poll ? pGuild.pollConfig.polls : pGuild.suggestionConfig.suggestions);
        const thisDecidableMan = arr.find(d => d._id == decidable._id);
        arr[arr.indexOf(thisDecidableMan)] = decidable;
        yield UpdatePGuild(message.client, pGuild, decidablesType, `Successfully saved the verdict for "${decidable.value}" to ${message.guild.name} PinguGuild.`, `I encountered an error, while saving the verdict for "${decidable.value}"`);
        switch (decidablesType) {
            case DecidablesTypes.Giveaway: return pGuild.giveawayConfig.giveaways;
            case DecidablesTypes.Poll: return pGuild.pollConfig.polls;
            case DecidablesTypes.Suggestion: return pGuild.suggestionConfig.suggestions;
        }
    });
}
function AddDecidableToPGuilds(params, decidable) {
    return __awaiter(this, void 0, void 0, function* () {
        const { message, pGuild, decidablesType } = params;
        switch (decidablesType) {
            case DecidablesTypes.Giveaway: pGuild.giveawayConfig.giveaways.push(decidable);
            case DecidablesTypes.Poll: pGuild.pollConfig.polls.push(decidable);
            case DecidablesTypes.Suggestion: pGuild.suggestionConfig.suggestions.push(decidable);
        }
        return yield UpdatePGuild(message.client, pGuild, decidablesType, `Added new ${decidablesType.toLowerCase()} to **${message.guild.name}**'s PinguGuild.`, `Saving ${decidablesType.toLowerCase()} in ${message.guild.name} failed!`);
    });
}
