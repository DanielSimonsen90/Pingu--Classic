"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinguEvents = void 0;
const discord_js_1 = require("discord.js");
const helpers_1 = require("../helpers");
class PinguEvents {
    static GetAuditLogs(guild, type, key, target = null, seconds = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!guild.me.hasPermission(helpers_1.DiscordPermissions.VIEW_AUDIT_LOG))
                return this.noAuditLog;
            let now = new Date(Date.now());
            let logs = (yield guild.fetchAuditLogs({ type }));
            now.setSeconds(now.getSeconds() - seconds);
            let filteredLogs = logs.entries.filter(e => e.createdTimestamp > now.getTime());
            try {
                return key ? filteredLogs.find(e => e.changes.find(change => change.key == key) && (target ? e.target == target : true)).executor.tag : filteredLogs.first().executor.tag;
            }
            catch (err) {
                if (err.message == `Cannot read property 'executor' of undefined`)
                    return this.noAuditLog;
            }
        });
    }
    static UnknownUpdate(old, current) {
        let oldArr = Object.keys(old);
        let currentArr = Object.keys(current);
        for (var i = 0; i < currentArr.length || i < oldArr.length; i++) {
            if (currentArr[i] != oldArr[i])
                return PinguEvents.SetDescriptionValues('Unknown', oldArr[i], currentArr[i]);
        }
        return null;
    }
    static SetDescription(type, description) {
        return `[**${type}**]\n\n${description}`;
    }
    static SetRemove(type, oldValue, newValue, SetString, RemoveString, descriptionMethod) {
        return newValue && !oldValue ? PinguEvents.SetDescription(type, SetString) :
            !newValue && oldValue ? PinguEvents.SetDescription(type, RemoveString) : descriptionMethod(type, oldValue, newValue);
    }
    static SetDescriptionValues(type, oldValue, newValue) {
        return PinguEvents.SetDescription(type, `Old: ${oldValue}\n\nNew: ${newValue}`);
    }
    static SetDescriptionValuesLink(type, oldValue, newValue) {
        return PinguEvents.SetDescription(type, `[Old](${oldValue})\n[New](${newValue})`);
    }
    /**@param type [**${type}**]
     * @param preArr Previous array
     * @param newArr Current array
     * @param callback pre/new.find(i => callback(i, preItem/newItem))*/
    static GoThroughArrays(type, preArr, newArr, callback) {
        let updateMessage = `[**${type}**] `;
        let added = GoThroguhArray(newArr, preArr);
        let removed = GoThroguhArray(preArr, newArr);
        if (added.length == 0 && removed.length != 0)
            return updateMessage += removed.join(`, `).substring(removed.join(', ').length - 2);
        else if (removed.length == 0 && added.length != 0)
            return updateMessage += added.join(`, `).substring(added.join(', ').length - 2);
        return updateMessage += `Unable to find out what changed!`;
        function GoThroguhArray(cycleArr, otherCycleArr) {
            let result = new Array();
            for (var item of cycleArr) {
                let old = otherCycleArr.find(i => callback(i, item));
                if (!old)
                    result.push(item);
            }
            return result;
        }
    }
    static GoThroughObjectArray(type, preArr, newArr) {
        let updateMessage = `[**${type}**]\n`;
        let changes = new discord_js_1.Collection();
        if (preArr.length > newArr.length)
            return updateMessage += `Removed ${type.toLowerCase()}`;
        else if (newArr.length > preArr.length)
            return updateMessage += `Added new ${type.toLowerCase()}`;
        for (var i = 0; i < newArr.length; i++) {
            let newKeys = Object.keys(newArr[i]);
            let preKeys = Object.keys(preArr[i]);
            newKeys.forEach(key => {
                if (newArr[key] == preArr[key])
                    return;
                else if (!preArr[key])
                    changes.set(key, `__Added__: ${newArr[key]}`);
                else
                    changes.set(key, `__Changed__: **${preArr[key]}** => **${newArr[key]}**`);
            });
            preKeys.forEach(key => {
                if (changes.get(key) || preKeys[key] == newKeys[key])
                    return;
                else if (!newArr[key])
                    changes.set(key, `__Removed__: ${preArr[key]}`);
            });
        }
        changes.keyArray().forEach(key => updateMessage += `**${key}**: ${changes.get(key)}\n`);
        return updateMessage;
    }
}
exports.PinguEvents = PinguEvents;
PinguEvents.Colors = {
    Create: `#18f151`,
    Update: `#ddfa00`,
    Delete: `#db1108`
};
PinguEvents.noAuditLog = `**No Audit Log Permissions**`;
