"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinguClient = exports.ToPinguClient = exports.Clients = void 0;
const discord_js_1 = require("discord.js");
const fs = require("fs");
exports.Clients = {
    PinguID: '562176550674366464',
    BetaID: '778288722055659520'
};
function ToPinguClient(client) {
    return client;
}
exports.ToPinguClient = ToPinguClient;
const PinguLibrary_1 = require("../library/PinguLibrary");
const PinguUser_1 = require("../user/PinguUser");
const handlers_1 = require("../handlers");
const Config_1 = require("../../helpers/Config");
class PinguClient extends discord_js_1.Client {
    constructor(config, subscribedEvents, commandsPath, evensPath, options) {
        super(options);
        //Public properties
        this.commands = new discord_js_1.Collection();
        this.events = new discord_js_1.Collection();
        this.DefaultEmbedColor = 3447003;
        this.config = new Config_1.Config(config);
        this.subscribedEvents = subscribedEvents.map(v => v == 'ready' ? 'onready' :
            v == 'debug' ? 'ondebug' :
                v);
        if (commandsPath)
            this.HandlePath(commandsPath, 'command');
        if (evensPath)
            this.HandlePath(evensPath, 'event');
    }
    static ToPinguClient(client) { return ToPinguClient(client); }
    //Pubic methods
    setActivity(options) {
        if (options)
            return this.user.setActivity(options);
        class Activity {
            constructor(text, type) {
                this.text = text;
                this.type = type;
            }
        }
        internalSetActivity(this);
        if (this.config.updateStats)
            UpdateStats(this);
        setInterval(internalSetActivity, 86400000);
        try {
            setInterval(UpdateStats, 86400000);
        }
        catch (err) {
            PinguLibrary_1.errorLog(this, `Updating Stats failed`, null, err);
        }
        function internalSetActivity(client) {
            let date = {
                day: new Date(Date.now()).getDate(),
                month: new Date(Date.now()).getMonth() + 1,
                year: new Date(Date.now()).getFullYear()
            };
            var activity = new Activity('your screams for', 'LISTENING');
            if (!client.isLive)
                activity = new Activity('Danho cry over bad code', 'WATCHING');
            if (date.month == 12)
                activity = date.day < 26 ?
                    new Activity('Jingle Bells...', 'LISTENING') :
                    new Activity('fireworks go boom', 'WATCHING');
            else if (date.month == 5)
                activity =
                    date.day == 3 ? new Activity(`Danho's birthday wishes`, 'LISTENING') :
                        date.day == 4 ? new Activity('Star Wars', 'WATCHING') : null;
            if (!activity)
                activity = new Activity('your screams for', 'LISTENING');
            client.user.setActivity(activity.text + ` ${client.DefaultPrefix}help`, { type: activity.type });
            PinguLibrary_1.raspberryLog(client);
        }
        function UpdateStats(client) {
            return __awaiter(this, void 0, void 0, function* () {
                let getChannel = (client, channelID) => PinguLibrary_1.SavedServers.PinguSupport(client).channels.cache.get(channelID);
                let channels = [
                    getChannel(client, '799596588859129887'),
                    getChannel(client, '799597092107583528'),
                    getChannel(client, '799597689792757771'),
                    getChannel(client, '799598372217683978'),
                    getChannel(client, '799598024971518002'),
                    getChannel(client, '799598765187137537') //Most known member
                ];
                let setName = (channel) => __awaiter(this, void 0, void 0, function* () {
                    let getInfo = (channel) => __awaiter(this, void 0, void 0, function* () {
                        switch (channel.id) {
                            case '799596588859129887': return getServersInfo(); //Servers
                            case '799597092107583528': return getUsersInfo(); //Users
                            case '799597689792757771': return yield getDailyLeader(); //Daily Leader
                            case '799598372217683978': return getRandomServer(); //Server of the Day
                            case '799598024971518002': return getRandomUser(); //User of the Day
                            case '799598765187137537': return getMostKnownUser(); //Most known User
                            default:
                                PinguLibrary_1.errorLog(client, `ID of ${channel.name} was not recognized!`);
                                return "No Info";
                        }
                        function getServersInfo() {
                            return client.guilds.cache.size.toString();
                        }
                        function getUsersInfo() {
                            return client.users.cache.size.toString();
                        }
                        function getDailyLeader() {
                            return __awaiter(this, void 0, void 0, function* () {
                                try {
                                    let pUser = (yield PinguUser_1.PinguUser.GetPUsers()).sort((a, b) => {
                                        try {
                                            return b.daily.streak - a.daily.streak;
                                        }
                                        catch (err) {
                                            PinguLibrary_1.errorLog(client, `unable to get daily streak difference between ${a.tag} and ${b.tag}`, null, err);
                                        }
                                    })[0];
                                    return `${pUser.tag} #${pUser.daily.streak}`;
                                }
                                catch (err) {
                                    PinguLibrary_1.errorLog(client, `Unable to get Daily Leader`, null, err);
                                }
                            });
                        }
                        function getRandomServer() {
                            let availableGuilds = client.guilds.cache.array().map(g => ![
                                PinguLibrary_1.SavedServers.DanhoMisc(client).id,
                                PinguLibrary_1.SavedServers.PinguEmotes(client).id,
                                PinguLibrary_1.SavedServers.PinguSupport(client).id,
                            ].includes(g.id) && g.name != undefined && g).filter(v => v);
                            let index = Math.floor(Math.random() * availableGuilds.length);
                            return availableGuilds[index].name;
                        }
                        function getRandomUser() {
                            let availableUsers = client.users.cache.array().map(u => !u.bot && u).filter(v => v);
                            return availableUsers[Math.floor(Math.random() * availableUsers.length)].tag;
                        }
                        function getMostKnownUser() {
                            let Users = new discord_js_1.Collection();
                            client.guilds.cache.forEach(guild => {
                                guild.members.cache.forEach(gm => {
                                    let { user } = gm;
                                    if (user.bot)
                                        return;
                                    if (!Users.has(user))
                                        return Users.set(user, 1);
                                    Users.set(user, Users.get(user) + 1);
                                });
                            });
                            let sorted = Users.sort((a, b) => b - a);
                            let strings = sorted.filter((v, u) => sorted.first() == v).map((v, u) => `${u.tag} | #${v}`);
                            return strings[Math.floor(Math.random() * strings.length)];
                        }
                    });
                    let channelName = channel.name.split(':')[0];
                    let info = yield getInfo(channel);
                    let newName = `${channelName}: ${info}`;
                    if (channel.name == newName)
                        return;
                    return channel.setName(newName);
                });
                for (var channel of channels)
                    setName(channel);
            });
        }
    }
    get isLive() { return this.user.id == PinguClient.Clients.PinguID; }
    toPClient(pGuild) {
        return pGuild.clients.find(c => c && c._id == this.user.id);
    }
    handleEvent(caller, ...args) {
        if (this.subscribedEvents.includes(caller))
            handlers_1.PinguEvent.HandleEvent(caller, this, this.events.get(caller).path, ...args);
        return this;
    }
    getEventParams(client, caller, ...args) {
        switch (caller) {
            case 'ready':
            case 'onready': return { caller: (caller == 'onready' ? 'ready' : caller), args: [client] };
            case 'debug':
            case 'ondebug': return { caller: (caller == 'ondebug' ? 'debug' : caller), args: [client] };
            default: return { caller: caller, args: args };
        }
    }
    login(token) {
        const _super = Object.create(null, {
            login: { get: () => super.login }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let res = yield _super.login.call(this, token);
            this.DefaultPrefix = this.isLive || !this.config.BetaPrefix ? this.config.Prefix : this.config.BetaPrefix;
            return res;
        });
    }
    //Private methods
    HandlePath(path, type) {
        let collection = fs.readdirSync(path);
        for (var file of collection) {
            try {
                if (file.endsWith(`.js`)) {
                    let module = require(`../../../../../${path}/${file}`);
                    module.path = `${path.substring(1, path.length)}/${file}`;
                    if (type == 'event') {
                        if (!module.name || !this.subscribedEvents.includes(module.name))
                            continue;
                        const type = module.name;
                        const event = module;
                        this.events.set(event.name, event);
                        // this.on(event.name as keyof ClientEvents, (...args) => this.handleEvent(event.name as keyof ClientEvents, ...args));
                        let { caller } = this.getEventParams(this, event.name); //Get original event
                        this.on(caller, (...params) => {
                            let pinguEventStuff = this.getEventParams(this, event.name, ...params); //Get Pingu event
                            this.handleEvent(event.name, ...pinguEventStuff.args); //Handle as Pingu event
                        });
                    }
                    else if (type == 'command')
                        this.commands.set(module.name, module);
                    else
                        PinguLibrary_1.errorLog(this, `"${type}" was not recognized!`);
                }
                else if (file.endsWith('.png') || file.toLowerCase().includes('archived'))
                    continue;
                else
                    this.HandlePath(`${path}/${file}`, type);
            }
            catch (err) {
                PinguLibrary_1.DanhoDM(`"${file}" threw an exception:\n${err.message}\n${err.stack}\n`);
            }
        }
    }
}
exports.PinguClient = PinguClient;
//Statics
PinguClient.Clients = exports.Clients;
