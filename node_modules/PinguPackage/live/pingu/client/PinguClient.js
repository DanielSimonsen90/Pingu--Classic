"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinguClient = exports.ToPinguClient = void 0;
const discord_js_1 = require("discord.js");
const fs = require("fs");
const request = require("request");
function ToPinguClient(client) {
    return client;
}
exports.ToPinguClient = ToPinguClient;
const BasePinguClient_1 = require("./BasePinguClient");
const handlers_1 = require("../handlers");
const PinguBadge_1 = require("../badge/PinguBadge");
const achievements_1 = require("../achievements");
class PinguClient extends BasePinguClient_1.default {
    constructor(config, permissions, subscribedEvents, commandsPath, eventsPath, options) {
        super(config, permissions, subscribedEvents, commandsPath, eventsPath, options);
    }
    //Statics
    static ToPinguClient(client) { return ToPinguClient(client); }
    //#endregion
    //#region Public Methods
    toPClient(pGuild) {
        return pGuild.clients.find(c => c && c._id == this.user.id);
    }
    emit(key, ...args) {
        return super.emit(key, ...args);
    }
    //#region Gets
    getSharedServers(user) {
        return this.guilds.cache.filter(g => g.members.cache.has(user.id)).array();
    }
    getTextChannel(guildId, channelName) {
        const guild = this.guilds.cache.get(guildId);
        if (!guild) {
            this.DanhoDM(`Unable to get guild from ${guildId}!`);
            return null;
        }
        const channel = guild.channels.cache.find(c => c.name == channelName);
        if (!channel) {
            this.DanhoDM(`Unable to get channel from ${channelName}!`);
            return null;
        }
        return channel;
    }
    getEmote(name, emoteGuild) {
        const dead = 'ðŸ˜µ';
        if (!name || !emoteGuild)
            return dead;
        const emote = this.guilds.cache.get(emoteGuild.id).emojis.cache.find(e => e.name == name);
        if (emote)
            return emote;
        this.log('error', `Unable to find emote **${name}** from ${emoteGuild.name}`);
        return dead;
    }
    getImage(script, imageName, extension = 'png') {
        return `./embedImages/${script}/${imageName}.${extension}`;
    }
    getBadges(user) { return PinguBadge_1.getBadges(user); }
    //#endregion
    requestImage(message, pGuildClient, caller, types, searchTerm) {
        return __awaiter(this, void 0, void 0, function* () {
            const { config } = this;
            if (!config || !config.api_key || !config.google_custom_search) {
                return this.log('error', `Unable to send ${caller}\nImage search requires both a YouTube API key and a Google Custom Search key!`, message.content, null, {
                    params: { message, pGuildClient, caller, types },
                    additional: { api_key: config.api_key, google_custom_search: config.google_custom_search }
                }).then(() => message.channel.send(`I was unable to search for a ${type}! I have contacted my developers...`));
            }
            // gets us a random result in first 5 pages
            const page = 1 + Math.floor(Math.random() * 5) * 10;
            //const type = Math.floor(Math.random() * 2) == 1 ? "Club Penguin" : "Pingu";
            const type = types[Math.floor(Math.random() * types.length)];
            if (!searchTerm)
                searchTerm = type => `${type} ${caller}`;
            // we request 10 items
            request(`https://www.googleapis.com/customsearch/v1?key=${config.api_key}&cx=${config.google_custom_search}&q=${searchTerm(type)}&searchType=image&alt=json&num=10&start=${page}`, (err, res, body) => __awaiter(this, void 0, void 0, function* () {
                if (err)
                    return this.log('error', `Error getting results when searching for ${searchTerm(type)}`, message.content, new Error(err), {
                        params: { message, pGuildClient, caller, types },
                        additional: { page, type, keys: { api_key: config.api_key, google_custom_search: config.google_custom_search } }
                    });
                // "https://www.googleapis.com/customsearch/v1?key=AIzaSyAeAr2Dv1umzuLes_zhlY0lON4Pf_uAKeM&cx=013524999991164939702:z24cpkwx9nz&q=pinguh&searchType=image&alt=json&num=10&start=31"
                try {
                    var data = JSON.parse(body);
                }
                catch (err) {
                    this.log('error', `Getting data in ${caller}, PinguLibrary.RequestImage()`, message.content, new Error(err), {
                        params: { message, pGuildClient, caller, types },
                        additional: { page, type, data }
                    });
                }
                if (!data) {
                    return this.log('error', `Getting data in ${caller}, PinguLibrary.RequestImage()`, message.content, null, {
                        params: { message, pGuildClient, caller, types },
                        additional: { page, type, data }
                    }).then(() => message.channel.send(`I was unable to recieve a gif! I have contacted my developers...`));
                }
                else if (!data.items || !data.items.length) {
                    return this.log('error', `Data for ${caller} has no items`, message.content, null, {
                        params: { message, pGuildClient, caller, types },
                        additional: { page, type, data }
                    }).then(() => message.channel.send(`I was unable to find a gif! I have contacted my developers...`));
                }
                return message.channel.send(new discord_js_1.MessageEmbed()
                    .setImage(data.items[Math.floor(Math.random() * data.items.length)].link)
                    .setColor(pGuildClient.embedColor || this.DefaultEmbedColor));
            }));
        });
    }
    AchievementCheck(data, key, type, callbackParams) {
        return __awaiter(this, void 0, void 0, function* () {
            return achievements_1.AchievementCheck(this, data, key, type, callbackParams);
        });
    }
    //#endregion
    //#region Private Methods
    handlePath(path, type) {
        let collection = fs.readdirSync(path);
        for (var file of collection) {
            try {
                if (file.endsWith(`.js`)) {
                    let module = require(`../../../../../${path}/${file}`);
                    module.path = `${path.substring(1, path.length)}/${file}`;
                    if (type == 'event') {
                        if (!module.name || !this.subscribedEvents.find(e => module.name == e))
                            continue;
                        const type = module.name;
                        const event = module;
                        this.events.set(event.name, event);
                        // this.on(event.name as keyof ClientEvents, (...args) => this.handleEvent(event.name as keyof ClientEvents, ...args));
                        let { caller } = this.getEventParams(this, event.name); //Get original event
                        this.on(caller, (...params) => {
                            let pinguEventStuff = this.getEventParams(this, event.name, ...params); //Get Pingu event
                            this.handleEvent(event.name, ...pinguEventStuff.args); //Handle as Pingu event
                        });
                    }
                    else if (type == 'command')
                        this.commands.set(module.name, module);
                    else
                        console.log(`"${type}" was not recognized!`);
                }
                else if (file.endsWith('.png') || file.toLowerCase().includes('archived'))
                    continue;
                else
                    this.handlePath(`${path}/${file}`, type);
            }
            catch (err) {
                console.log(`"${file}" threw an exception:\n${err.message}\n${err.stack}\n`);
            }
        }
    }
    handleEvent(caller, ...args) {
        if (this.subscribedEvents.find(e => e == caller))
            handlers_1.PinguEvent.HandleEvent(caller, this, this.events.get(caller).path, ...args);
        return this;
    }
    getEventParams(client, caller, ...args) {
        switch (caller) {
            case 'ready':
            case 'onready': return { caller: (caller == 'onready' ? 'ready' : caller), args: [client] };
            case 'debug':
            case 'ondebug': return { caller: (caller == 'ondebug' ? 'debug' : caller), args: [client] };
            default: return { caller: caller, args: args };
        }
    }
}
exports.PinguClient = PinguClient;
exports.default = PinguClient;
