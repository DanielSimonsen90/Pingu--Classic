"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinguLibrary = void 0;
const discord_js_1 = require("discord.js");
const mongoose = require("mongoose");
const config = require("../../config.json");
const client_1 = require("./client");
const permissions_1 = require("./permissions");
const servers_1 = require("./servers");
const developers_1 = require("./developers");
const channels_1 = require("./channels");
const logChannels_1 = require("./logChannels");
const helpers_1 = require("../../helpers");
class PinguLibrary {
    //#region Client
    static setActivity(client) { return client_1.setActivity(client); }
    static DefaultPrefix(client) { return client_1.DefaultPrefix(client); }
    //#endregion
    //#region Permissions
    static PermissionCheck(check, permissions) { return permissions_1.PermissionCheck(check, permissions); }
    static Permissions() { return permissions_1.Permissions(); }
    static getServer(client, id) { return servers_1.getServer(client, id); }
    static getSharedServers(client, user) {
        return __awaiter(this, void 0, void 0, function* () { return servers_1.getSharedServers(client, user); });
    }
    static CacheDevelopers(client) { return developers_1.CacheDevelopers(client); }
    static isPinguDev(user) { return developers_1.isPinguDev(user); }
    //#endregion
    //#region Channels
    static getChannel(client, guildID, channelname) { return channels_1.getChannel(client, guildID, channelname); }
    static outages(client, message) {
        return __awaiter(this, void 0, void 0, function* () { return channels_1.outages(client, message); });
    }
    static DanhoDM(client, message) {
        return __awaiter(this, void 0, void 0, function* () { return channels_1.DanhoDM(client, message); });
    }
    static errorLog(client, message, messageContent, err, errorID) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.errorLog(client, message, messageContent, err, errorID);
        });
    }
    static pGuildLog(client, script, message, err) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.pGuildLog(client, script, message, err);
        });
    }
    static pUserLog(client, script, message, err) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.pUserLog(client, script, message, err);
        });
    }
    static consoleLog(client, message) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.consoleLog(client, message);
        });
    }
    static eventLog(client, content) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.eventLog(client, content);
        });
    }
    static tellLog(client, sender, reciever, message) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.tellLog(client, sender, reciever, message);
        });
    }
    static latencyCheck(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.latencyCheck(message);
        });
    }
    static raspberryLog(client) {
        return __awaiter(this, void 0, void 0, function* () {
            return logChannels_1.raspberryLog(client);
        });
    }
    //#endregion
    static getEmote(client, name, emoteGuild) {
        if (!client || !name || !emoteGuild)
            return 'ðŸ˜µ';
        let emote = client.guilds.cache.find(g => g.id == emoteGuild.id).emojis.cache.find(e => e.name == name);
        if (emote)
            return emote;
        PinguLibrary.errorLog(client, `Unable to find Emote **${name}** from ${emoteGuild.name}`);
        return 'ðŸ˜µ';
    }
    static getImage(script, imageName) {
        return `./embedImages/${script}_${imageName}.png`;
    }
    static DBExecute(client, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield mongoose.connect(`mongodb+srv://Pingu:${config.mongoPass}@pingudb.kh2uq.mongodb.net/PinguDB?retryWrites=true&w=majority`, {
                    useNewUrlParser: true,
                    useUnifiedTopology: true
                });
                yield callback(mongoose);
            }
            catch (err) {
                PinguLibrary.errorLog(client, 'Mongo error', null, new helpers_1.Error(err));
            }
            //finally { mongoose.connection.close(); }
        });
    }
    static BlankEmbedField(inline = false) {
        return new helpers_1.EmbedField('\u200B', '\u200B', inline);
    }
}
exports.PinguLibrary = PinguLibrary;
PinguLibrary.DefaultEmbedColor = client_1.DefaultEmbedColor;
PinguLibrary.Clients = client_1.Clients;
PinguLibrary.PermissionGranted = permissions_1.PermissionGranted;
//#endregion
//#region Servers
PinguLibrary.PinguSupportInvite = `https://discord.gg/gbxRV4Ekvh`;
PinguLibrary.SavedServers = servers_1.SavedServers;
//#endregion
//#region Pingu Developers
PinguLibrary.Developers = developers_1.Developers;
//#endregion
//#region Log Channels
PinguLibrary.errorCache = new discord_js_1.Collection();
