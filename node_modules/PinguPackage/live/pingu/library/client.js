"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Clients = exports.DefaultPrefix = exports.DefaultEmbedColor = exports.setActivity = void 0;
const discord_js_1 = require("discord.js");
const PinguLibrary_1 = require("../library/PinguLibrary");
const PinguUser_1 = require("../user/PinguUser");
const config = require("../../config.json");
const { Prefix, BetaPrefix, updateStats } = config;
function setActivity(client) {
    class Activity {
        constructor(text, type) {
            this.text = text;
            this.type = type;
        }
    }
    internalSetActivity();
    if (updateStats)
        UpdateStats();
    setInterval(internalSetActivity, 86400000);
    try {
        setInterval(UpdateStats, 86400000);
    }
    catch (err) {
        PinguLibrary_1.PinguLibrary.errorLog(client, `Updating Stats failed`, null, err);
    }
    function internalSetActivity() {
        let date = {
            day: new Date(Date.now()).getDate(),
            month: new Date(Date.now()).getMonth() + 1,
            year: new Date(Date.now()).getFullYear()
        };
        var activity = new Activity('your screams for', 'LISTENING');
        if (client.user.id == PinguLibrary_1.PinguLibrary.Clients.BetaID)
            activity = new Activity('Danho cry over bad code', 'WATCHING');
        if (date.month == 12)
            activity = date.day < 26 ?
                new Activity('Jingle Bells...', 'LISTENING') :
                new Activity('fireworks go boom', 'WATCHING');
        else if (date.month == 5)
            activity =
                date.day == 3 ? new Activity(`Danho's birthday wishes`, 'LISTENING') :
                    date.day == 4 ? new Activity('Star Wars', 'WATCHING') : null;
        if (!activity)
            activity = new Activity('your screams for', 'LISTENING');
        client.user.setActivity(activity.text + ` ${PinguLibrary_1.PinguLibrary.DefaultPrefix(client)}help`, { type: activity.type });
        PinguLibrary_1.PinguLibrary.raspberryLog(client);
    }
    function UpdateStats() {
        return __awaiter(this, void 0, void 0, function* () {
            let getChannel = (client, channelID) => PinguLibrary_1.PinguLibrary.SavedServers.PinguSupport(client).channels.cache.get(channelID);
            let channels = [
                getChannel(client, '799596588859129887'),
                getChannel(client, '799597092107583528'),
                getChannel(client, '799597689792757771'),
                getChannel(client, '799598372217683978'),
                getChannel(client, '799598024971518002'),
                getChannel(client, '799598765187137537') //Most known member
            ];
            let setName = (channel) => __awaiter(this, void 0, void 0, function* () {
                let getInfo = (channel) => __awaiter(this, void 0, void 0, function* () {
                    switch (channel.id) {
                        case '799596588859129887': return getServersInfo(); //Servers
                        case '799597092107583528': return getUsersInfo(); //Users
                        case '799597689792757771': return yield getDailyLeader(); //Daily Leader
                        case '799598372217683978': return getRandomServer(); //Server of the Day
                        case '799598024971518002': return getRandomUser(); //User of the Day
                        case '799598765187137537': return getMostKnownUser(); //Most known User
                        default:
                            PinguLibrary_1.PinguLibrary.errorLog(client, `ID of ${channel.name} was not recognized!`);
                            return "No Info";
                    }
                    function getServersInfo() {
                        return client.guilds.cache.size.toString();
                    }
                    function getUsersInfo() {
                        return client.users.cache.size.toString();
                    }
                    function getDailyLeader() {
                        return __awaiter(this, void 0, void 0, function* () {
                            try {
                                let pUser = (yield PinguUser_1.PinguUser.GetPUsers()).sort((a, b) => {
                                    try {
                                        return b.daily.streak - a.daily.streak;
                                    }
                                    catch (err) {
                                        PinguLibrary_1.PinguLibrary.errorLog(client, `unable to get daily streak difference between ${a.tag} and ${b.tag}`, null, err);
                                    }
                                })[0];
                                return `${pUser.tag} #${pUser.daily.streak}`;
                            }
                            catch (err) {
                                PinguLibrary_1.PinguLibrary.errorLog(client, `Unable to get Daily Leader`, null, err);
                            }
                        });
                    }
                    function getRandomServer() {
                        let availableGuilds = client.guilds.cache.array().map(g => ![
                            PinguLibrary_1.PinguLibrary.SavedServers.DanhoMisc(client).id,
                            PinguLibrary_1.PinguLibrary.SavedServers.PinguEmotes(client).id,
                            PinguLibrary_1.PinguLibrary.SavedServers.PinguSupport(client).id,
                        ].includes(g.id) && g.name != undefined && g).filter(v => v);
                        let index = Math.floor(Math.random() * availableGuilds.length);
                        return availableGuilds[index].name;
                    }
                    function getRandomUser() {
                        let availableUsers = client.users.cache.array().map(u => !u.bot && u).filter(v => v);
                        return availableUsers[Math.floor(Math.random() * availableUsers.length)].tag;
                    }
                    function getMostKnownUser() {
                        let Users = new discord_js_1.Collection();
                        client.guilds.cache.forEach(guild => {
                            guild.members.cache.forEach(gm => {
                                let { user } = gm;
                                if (user.bot)
                                    return;
                                if (!Users.has(user))
                                    return Users.set(user, 1);
                                Users.set(user, Users.get(user) + 1);
                            });
                        });
                        let sorted = Users.sort((a, b) => b - a);
                        let strings = sorted.filter((v, u) => sorted.first() == v).map((v, u) => `${u.tag} | #${v}`);
                        return strings[Math.floor(Math.random() * strings.length)];
                    }
                });
                let channelName = channel.name.split(':')[0];
                let info = yield getInfo(channel);
                let newName = `${channelName}: ${info}`;
                if (channel.name == newName)
                    return;
                return channel.setName(newName);
            });
            for (var channel of channels)
                setName(channel);
        });
    }
}
exports.setActivity = setActivity;
exports.DefaultEmbedColor = 3447003;
function DefaultPrefix(client) {
    return client.user.id == PinguLibrary_1.PinguLibrary.Clients.PinguID ? Prefix : BetaPrefix;
}
exports.DefaultPrefix = DefaultPrefix;
exports.Clients = {
    PinguID: '562176550674366464',
    BetaID: '778288722055659520'
};
